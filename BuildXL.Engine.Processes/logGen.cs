// <auto-generated/>
#nullable enable
namespace BuildXL.Processes.Tracing
{
    using System.Diagnostics.Tracing;
    using BuildXL.Processes.Tracing;

#pragma warning disable 219
    /// <summary>
    /// Logger interface
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("csc.exe", "4.1100.24.46003")]
    public interface IProcessesLogger : global::BuildXL.Utilities.Instrumentation.Common.ILogger
    {
        /// <summary>
        /// (Verbose) - [{1}] File access on '{3}' with {2}
        /// </summary>
        void PipProcessFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path);
        /// <summary>
        /// (Error) - [{1}] Process created a symlink at '{2}'. Symlink outputs are not currently supported. This error was introduced by /FailSymlinkCreationflag.
        /// </summary>
        void PipFailSymlinkCreation(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path);
        /// <summary>
        /// (Error) - A debug {ShortProductName} is using a non-debug DetoursServices.dll.
        /// </summary>
        void PipInvalidDetoursDebugFlag1(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context);
        /// <summary>
        /// (Error) - A non-debug {ShortProductName} is using a debug DetoursServices.dll.
        /// </summary>
        void PipInvalidDetoursDebugFlag2(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context);
        /// <summary>
        /// (Warning) - [{1}] Process start failed with error code {2:X8}: {3}. Pip may be retried or failed.
        /// </summary>
        void PipProcessStartFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string message);
        /// <summary>
        /// (Error) - [{1}] Process start failed with error code {2:X8}: File '{3}' was not found on disk. The tool is referred to in '{4}({5})'.
        /// </summary>
        void PipProcessFileNotFound(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string filename, string specFile, int position);
        /// <summary>
        /// (Verbose) - [{1}] Process exited cleanly with exit code {2}
        /// </summary>
        void PipProcessFinished(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode);
        /// <summary>
        /// (Verbose) - [{1}] Process failed with exit code {2}
        /// </summary>
        void PipProcessFinishedFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode);
        /// <summary>
        /// (Error) - [{1}] Process failed with message parsing error: {2}.
        /// </summary>
        void PipProcessMessageParsingError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string error);
        /// <summary>
        /// (Error) - [{1}] Failed to instrument one or more processes
        /// </summary>
        void PipProcessFinishedDetourFailures(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription);
        /// <summary>
        /// (Verbose) - [{1}] Disallowed file access in temp directory was blocked on '{3}' with {2}; declare that this pip needs a temp directory.
        /// </summary>
        void PipProcessDisallowedTempFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path);
        /// <summary>
        /// (Verbose) - [{1}] No file access for output: {2}. Detours discovered inconsistency in detouring some child processes. Information about the inconsistency can be found in the BuildXL log file. Please, restart the build...
        /// </summary>
        void PipOutputNotAccessed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string outputFileName);
        /// <summary>
        /// (Verbose) - [{1}, {2}, {3}] - Disallowed file access was detected on '{5}' with {4}.
        /// </summary>
        void PipProcessDisallowedFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path);
        /// <summary>
        /// (Warning) - [{1}, {2}, {3}] - Disallowed NtCreateFile access was detected on '{5}' with {4}. This warning will become an error if the '/unsafe_ignoreNtCreateFile+' is removed.
        /// </summary>
        void PipProcessDisallowedNtCreateFileAccessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path);
        /// <summary>
        /// (Warning) - [{1}] Process ran for {2}ms, which is longer than the warning timeout of {3}ms; the process will be terminated if it ever runs longer than {4}ms
        /// </summary>
        void PipProcessTookTooLongWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long softMax, long hardMax);
        /// <summary>
        /// (Error) - [{1}] Process terminated because it took too long: {2}ms; the timeout is set to {3}ms. {4} \r\n Process Output: \r\n {5}
        /// </summary>
        void PipProcessTookTooLongError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long time, string dumpDetails, string outputToLog);
        /// <summary>
        /// (Verbose) - [{1}] Process standard output at '{2}'
        /// </summary>
        void PipProcessStandardOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path);
        /// <summary>
        /// (Verbose) - [{1}] Process standard error at '{2}'
        /// </summary>
        void PipProcessStandardError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path);
        /// <summary>
        /// (Verbose) - [{1}] File access table entry '{2}'
        /// </summary>
        void PipProcessFileAccessTableEntry(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string value);
        /// <summary>
        /// (Warning) - [{1}] Access to the following path will be ignored, since the path could not be parsed: '{3}' (Accessed via {2})
        /// </summary>
        void PipProcessFailedToParsePathOfFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path);
        /// <summary>
        /// (Verbose) - [{1}] Access to the following path will be ignored, since the path is a path to a device: '{3}' (Accessed via {2})
        /// </summary>
        void PipProcessIgnoringPathOfSpecialDeviceFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path);
        /// <summary>
        /// (Verbose) - [{1}] Access to the following path will be ignored, since the path contains wildcard characters: '{3}' (Accessed via {2})
        /// </summary>
        void PipProcessIgnoringPathWithWildcardsFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path);
        /// <summary>
        /// (Verbose) - [{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.
        /// </summary>
        void PipProcessDisallowedFileAccessAllowlistedNonCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path);
        /// <summary>
        /// (Verbose) - [{1}] Disallowed file access (cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.
        /// </summary>
        void PipProcessDisallowedFileAccessAllowlistedCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path);
        /// <summary>
        /// (Warning) - [{1}] Failed to parse tool path '{3}' at character '{4}' that accessed '{2}'. File access allowlist entries matching on tool paths will not be checked for this access.
        /// </summary>
        void FileAccessAllowlistFailedToParsePath(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string processPath, int characterWithError);
        /// <summary>
        /// (Error) - [{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message is an error because non-cacheable allowlist matches are not allowed in distributed builds.
        /// </summary>
        void PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path);
        /// <summary>
        /// (Verbose) - [{1}] Process with id {2} at '{3}'
        /// </summary>
        void PipProcess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint id, string path);
        /// <summary>
        /// (Error) - Failed to instrument process ID {0} for file monitoring on behalf of an existing instrumented process, error: {1}. Most likely reason for this error is the run time for the process exceeded the allowed timeout for the process to complete.
        /// </summary>
        void BrokeredDetoursInjectionFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, uint processId, string error);
        /// <summary>
        /// (Verbose) - [Pip{pipSemiStableHash:X16}] Detours Debug Message: {message}
        /// </summary>
        void LogDetoursDebugMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string message);
        /// <summary>
        /// (Verbose) - Find AnyBuild client for process remoting at '{anyBuildInstallDir}'
        /// </summary>
        void FindAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string anyBuildInstallDir);
        /// <summary>
        /// (Verbose) - Find or start AnyBuild daemon manager for process remoting with arguments '{args}' (log directory: '{logDir}')
        /// </summary>
        void FindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string args, string logDir);
        /// <summary>
        /// (Warning) - Exception on finding or starting AnyBuild daemon: {exception}
        /// </summary>
        void ExceptionOnFindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception);
        /// <summary>
        /// (Warning) - Exception on getting AnyBuild remote process factory: {exception}
        /// </summary>
        void ExceptionOnGetAnyBuildRemoteProcessFactory(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception);
        /// <summary>
        /// (Warning) - Exception on finding AnyBuild client: {exception}
        /// </summary>
        void ExceptionOnFindingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception);
        /// <summary>
        /// (Verbose) - AnyBuild repo config overrides: {config}
        /// </summary>
        void AnyBuildRepoConfigOverrides(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string config);
        /// <summary>
        /// (Informational) - Installing AnyBuild client from '{source}' (ring: {ring})
        /// </summary>
        void InstallAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring);
        /// <summary>
        /// (Verbose) - Installing AnyBuild client from '{source}' (ring: {ring}): {reason}
        /// </summary>
        void InstallAnyBuildClientDetails(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring, string reason);
        /// <summary>
        /// (Warning) - Failed downloading AnyBuild client: {message}
        /// </summary>
        void FailedDownloadingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message);
        /// <summary>
        /// (Warning) - Failed installing AnyBuild client: {message}
        /// </summary>
        void FailedInstallingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message);
        /// <summary>
        /// (Verbose) - Finished installing AnyBuild client: {message}
        /// </summary>
        void FinishedInstallAnyBuild(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message);
        /// <summary>
        /// (Verbose) - Execute AnyBuild bootstrapper: {command}
        /// </summary>
        void ExecuteAnyBuildBootstrapper(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string command);
        /// <summary>
        /// (Verbose) - [{1}] Apple sandbox-exec policy for pip generated: {policyFilePath}
        /// </summary>
        void LogAppleSandboxPolicyGenerated(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string policyFilePath);
        /// <summary>
        /// (Verbose) - [{1}] Maximum detours heap size for process in the pip is {maxDetoursHeapSizeInBytes} bytes. The processName '{processName}'. The processId is: {processId}. The manifestSize in bytes is: {manifestSizeInBytes}. The finalDetoursHeapSize in bytes is: {finalDetoursHeapSizeInBytes}. The allocatedPoolEntries is: {allocatedPoolEntries}. The maxHandleMapEntries is: {maxHandleMapEntries}. The handleMapEntries is: {handleMapEntries}.
        /// </summary>
        void LogDetoursMaxHeapSize(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, ulong maxDetoursHeapSizeInBytes, string processName, uint processId, uint manifestSizeInBytes, ulong finalDetoursHeapSizeInBytes, uint allocatedPoolEntries, ulong maxHandleMapEntries, ulong handleMapEntries);
        /// <summary>
        /// (Error) - [{1}] Detoured process emitted failure information that could not be transmitted back to {ShortProductName}. Diagnostic file content: {2}
        /// </summary>
        void LogInternalDetoursErrorFileNotEmpty(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message);
        /// <summary>
        /// (Error) - [{1}] Failed to create directory for the internal Detours error file. Path: {path}. Error: {message}
        /// </summary>
        void LogFailedToCreateDirectoryForInternalDetoursFailureFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string message);
        /// <summary>
        /// (Error) - [{1}] Failed checking for detours backup communication file existence. Pip will be treated as a failure. Error: {message}.
        /// </summary>
        void LogGettingInternalDetoursErrorFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message);
        /// <summary>
        /// (Verbose) - [{1}] The number of messages sent successfully by detoured processes did not match the number received by the {MainExecutableName} process, which indicates lost messages. {MainExecutableName} cannot reliably use the file accesses reported by Detours for caching the process pip. LostMessageCount: {lastConfirmedMessageCount}
        /// </summary>
        void LogMismatchedDetoursCountLostMessages(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount);
        /// <summary>
        /// (Verbose) - [{1}] The number of messages sent by detoured processes did not match the number received by the {MainExecutableName} process, which indicates that calls to detoured APIs terminated abruptly, and indicates that the detoured processes could have a non-deterministic file access behavior. This can cause the process pip to be cached with different sets of file accesses as cache keys. DiffBetweenSendAttemptsAndReceived: {lastMessageCount}. LostMessageCount: {lastConfirmedMessageCount} (&amp;lt;= 0 means no lost message).
        /// </summary>
        void LogMismatchedDetoursCount(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount);
        /// <summary>
        /// (Error) - [{1}] Can't open semaphore for counting Detours messages. Full failure message: {2}
        /// </summary>
        void LogMessageCountSemaphoreOpenFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string failureMessage);
        /// <summary>
        /// (Error) - [{1}] Process command line is longer than {3} characters: {2}
        /// </summary>
        void PipProcessCommandLineTooLong(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string commandLine, int maxLength);
        /// <summary>
        /// (Error) - [{1}] Process warning regular expression is invalid, pattern is {2}, options are {3}
        /// </summary>
        void PipProcessInvalidWarningRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options);
        /// <summary>
        /// (Error) - [{1}] Process error regular expression is invalid, pattern is {2}, options are {3}
        /// </summary>
        void PipProcessInvalidErrorRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options);
        /// <summary>
        /// (Error) - [{1}] Unexpected child processes survived: {2} process(es){3}
        /// </summary>
        void PipProcessChildrenSurvivedError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths);
        /// <summary>
        /// (Verbose) - [{1}] Too many child processes survived: {2} process(es){3}
        /// </summary>
        void PipProcessChildrenSurvivedTooMany(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths);
        /// <summary>
        /// (Verbose) - [{1}] Process and/or job containing child processes killed
        /// </summary>
        void PipProcessChildrenSurvivedKilled(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription);
        /// <summary>
        /// (Verbose) - [{1}, {2}, {3}]Process was expected to write an output file at '{4}', but that file is not present.
        /// </summary>
        void PipProcessMissingExpectedOutputOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string path);
        /// <summary>
        /// (Error) - [{1}, {2}, {3}]Process exited succesfully but wrote to standard error. The process is configured to fail in this case, even if the exit code was successful.
        /// </summary>
        void PipProcessWroteToStandardErrorOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory);
        /// <summary>
        /// (Error) - [{1}] - Process was expected to write the following output files, but those files are not present.:\r\n{2}
        /// </summary>
        void PipProcessExpectedMissingOutputs(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string paths);
        /// <summary>
        /// (Error) - [{1}, {2}, {3}]Process output directories could not be prepared, path '{2}', error code {3:X8}: {4}
        /// </summary>
        void PipProcessOutputPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message, string exception);
        /// <summary>
        /// (Verbose) - [{1}] Process output '{2}' could not be prepared. Attempting to delete it from within the VM on the next retry.
        /// </summary>
        void PipProcessOutputPreparationToBeRetriedInVM(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path);
        /// <summary>
        /// (Error) - [{1}] Process standard I/O failure at path '{2}', error code {3:X8}: {4}
        /// </summary>
        void PipStandardIOFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message);
        /// <summary>
        /// (Verbose) - [{1}] Pip had unclean exit. Canceled: {canceled}, Error code {errorCode}, Killed: {killed}, # Surviving child errors: {numSurvivingChildErrors}
        /// </summary>
        void PipExitedUncleanly(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool canceled, int errorCode, bool killed, int numSurvivingChildErrors);
        /// <summary>
        /// (Verbose) - [{1}] Pip will be retried because its reported process '{process}' with pid '{processId}' exited with Azure Watson's 0xDEAD exit code
        /// </summary>
        void PipRetryDueToExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, uint processId);
        /// <summary>
        /// (Warning) - [{1}] Pip finished with some process (can be a child process) '{process} {args}' with pid '{processId}' exited with Azure Watson's 0xDEAD exit code. Pip will not be cached if warning is treated as an error.
        /// </summary>
        void PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, string args, uint processId);
        /// <summary>
        /// (Verbose) - [{1}, {2}, {3}] Unexpected standard input exception: {4}
        /// </summary>
        void PipProcessStandardInputException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string exceptionMessage);
        /// <summary>
        /// (Error) - [{1}, {2}, {3}]The tool '{toolName}' cannot access the file '{file}' because it is being used by another process: \r\n{reason}
        /// </summary>
        void PipProcessToolErrorDueToHandleToFileBeingUsed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string toolName, string file, string reason);
        /// <summary>
        /// (Error) - [{1}, {2}, {3}] - failed with exit code {exitCode}{optionalMessage}\r\n{outputToLog}\r\n{messageAboutPathsToLog}\r\n{pathsToLog}
        /// </summary>
        void PipProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog, int exitCode, string optionalMessage, string shortPipDescription, long pipExecutionTimeMs);
        /// <summary>
        /// (Warning) - [{1}, {2}, {3}] - warnings\r\n{outputToLog}\r\n{messageAboutPathsToLog}\r\n{pathsToLog}
        /// </summary>
        void PipProcessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog);
        /// <summary>
        /// (Verbose) - [{1}, {2}, {3}]\r\n{4}
        /// </summary>
        void PipProcessOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string outputToLog);
        /// <summary>
        /// (Warning) - [{1}] Failed to clean temp directory at '{directory}'. Pip may be retried or failed. {exceptionMessage}
        /// </summary>
        void PipTempDirectoryCleanupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage);
        /// <summary>
        /// (Warning) - [{1}] Failed to create temp directory at '{directory}'. Pip may be retried or failed. {exceptionMessage}
        /// </summary>
        void PipTempDirectorySetupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage);
        /// <summary>
        /// (Error) - [{1}] Failed to create directory symlink '{directorySymlink}' as a redirection for temp directory '{tempDirectory}'. {exceptionMessage}
        /// </summary>
        void PipTempSymlinkRedirectionError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory, string exceptionMessage);
        /// <summary>
        /// (Verbose) - [{1}] Create directory symlink '{directorySymlink}' as a redirection for temp directory '{tempDirectory}'
        /// </summary>
        void PipTempSymlinkRedirection(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory);
        /// <summary>
        /// (Warning) - [{1}] Failed to create dump for timed out process. {exceptionMessage}
        /// </summary>
        void PipFailedToCreateDumpFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string exceptionMessage);
        /// <summary>
        /// (Verbose) - [{1}, {2}, {3}]Retry to start pip for {retryNumber} time(s) due to the following error: {error}
        /// </summary>
        void RetryStartPipDueToErrorPartialCopyDuringDetours(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int error, int retryNumber);
        /// <summary>
        /// (Warning) - Unexpected duplicate environment variable encountered. Variable '{0}' has already been defined with value '{1}'. The other occurrence with value '{2}' will be ignored.
        /// </summary>
        void DuplicateWindowsEnvironmentVariableEncountered(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string key, string existingValue, string ignoredValue);
        /// <summary>
        /// (Verbose) - [{1}] File access on file '{3}' requested with Read/Write but granted for Read only by process with ID: {2}.
        /// </summary>
        void ReadWriteFileAccessConvertedToReadMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint processId, string path);
        /// <summary>
        /// (Warning) - [{1}] This pip might have failed because of converting Read/Write file access to a Read file access. Examine the execution log for information on which files the Read/Write access request was converted to Read access request.
        /// </summary>
        void ReadWriteFileAccessConvertedToReadWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription);
        /// <summary>
        /// (Error) - [{1}, {2}, {3}]Process response file could not be prepared, path '{2}', error code {3:X8}: {4}
        /// </summary>
        void PipProcessResponseFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message);
        /// <summary>
        /// (Verbose) - [{1}] Failed to preserve output directory '{directory}' because '{file}' cannot be made private, contents of the directory will be deleted
        /// </summary>
        void PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string file);
        /// <summary>
        /// (Verbose) - [{1}] Output directory '{directory}' is not preserved because /unsafe_IgnorePreserveOutputsPrivatization. This can cause failure in pip execution.
        /// </summary>
        void PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory);
        /// <summary>
        /// (Error) - [{1}] File containing change affected inputs could not be prepared, path '{path}', error code {errorCode:X8}: {message}
        /// </summary>
        void PipProcessChangeAffectedInputsWrittenFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message);
        /// <summary>
        /// (Error) - [{1}] Cannot create a hardlink from '{sourceFile}' to '{destinationFile}' when merging outputs to their original location: {failedStatus}
        /// </summary>
        void FailedToCreateHardlinkOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile, string failedStatus);
        /// <summary>
        /// (Error) - [{1}] A disallowed double write was detected when merging '{sourceFile}' to '{destinationFile}'.
        /// </summary>
        void DisallowedDoubleWriteOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile);
        /// <summary>
        /// (Verbose) - [{1}] Detected double write in '{destinationFile}' when merging outputs to their original location. The double write is allowed due to configured policy.
        /// </summary>
        void DoubleWriteAllowedDueToPolicy(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile);
        /// <summary>
        /// (Verbose) - [{1}] Process execution via external tool '{tool}' starts
        /// </summary>
        void PipProcessStartExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool);
        /// <summary>
        /// (Verbose) - [{1}] Process execution via external tool finished with the tool's exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        void PipProcessFinishedExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr);
        /// <summary>
        /// (Verbose) - [{1}] Remoting process execution via '{tool}' starts
        /// </summary>
        void PipProcessStartRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool);
        /// <summary>
        /// (Verbose) - [{1}] Remoting process execution via external tool finished with the tool's exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        void PipProcessFinishedRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr);
        /// <summary>
        /// (Verbose) - [{1}] Process execution in VM starts
        /// </summary>
        void PipProcessStartExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription);
        /// <summary>
        /// (Verbose) - [{1}] Process execution in VM finished with VM's command proxy exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        void PipProcessFinishedExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr);
        /// <summary>
        /// (Verbose) - [{1}] External execution: {message}
        /// </summary>
        void PipProcessExternalExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message);
        /// <summary>
        /// (Warning) - [{1}] Process needs to be executed externally because (require admin privilege: {requiredAdminPrivilege} | execution mode: {executionMode}), but instead it executes internally because (Win OS: {isWinOS} | listener existence: {existsListener})
        /// </summary>
        void PipProcessNeedsExecuteExternalButExecuteInternal(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool requiredAdminPrivilege, string executionMode, bool isWinOS, bool existsListener);
        /// <summary>
        /// (Verbose) - [{pipSemiStableHash}] Done with phase '{phaseName}' in {duration}.  {extraInfo}
        /// </summary>
        void LogPhaseDuration(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string phaseName, string duration, string extraInfo);
        /// <summary>
        /// (Error) - [{pipDescription}] Failed to delete shared opaque output files recorded in '{sidebandFile}':{files}.  Reason: {failure}
        /// </summary>
        void CannotDeleteSharedOpaqueOutputFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, string failure);
        /// <summary>
        /// (Verbose) - [{pipDescription}] Lazily deleted {count} shared opaque output files recorded in '{sidebandFile}':{files}.
        /// </summary>
        void SharedOpaqueOutputsDeletedLazily(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, int count);
        /// <summary>
        /// (Error) - Cannot read sideband file '{fileName}': {error}
        /// </summary>
        void CannotReadSidebandFileError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error);
        /// <summary>
        /// (Warning) - Cannot read sideband file '{fileName}': {error}
        /// </summary>
        void CannotReadSidebandFileWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error);
        /// <summary>
        /// (Verbose) - [{pipSemiStableHash}] occurred an error for {failedOperation}: {errorCode}
        /// </summary>
        void ResumeOrSuspendProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string failedOperation, int errorCode);
        /// <summary>
        /// (Verbose) - {operation} attempt failed with exception. {exception}
        /// </summary>
        void ResumeOrSuspendException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string operation, string exception);
        /// <summary>
        /// (Error) - [{pipDescription}] Failed to probe '{path}' under a shared opaque directory : {details}
        /// </summary>
        void CannotProbeOutputUnderSharedOpaque(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string path, string details);
        /// <summary>
        /// (Verbose) - [{1}] Failure during dumping unexpected surviving child processes for Process: '{processName}'. Status: {status}
        /// </summary>
        void DumpSurvivingPipProcessChildrenStatus(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string processName, string status);
        /// <summary>
        /// (Error) - [{pipDescription}] The output file '{assertedOutput}' existence was asserted under output directory root '{outputDirectoryRoot}' but the file was not produced by the pip.
        /// </summary>
        void ExistenceAssertionUnderOutputDirectoryFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string assertedOutput, string outputDirectoryRoot);
        /// <summary>
        /// (Warning) - [{pipSemiStableHash}] Logging process StandardOutput/StandardError timed out after exceeding '{timeoutInMinutes}' minutes. This may be caused by the default terminal being Windows Terminal, workaround this by switching the default terminal to 'Windows Console Host' in Windows settings or Windows Terminal settings. Output streams may be incomplete due to this error.
        /// </summary>
        void SandboxedProcessResultLogOutputTimeout(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, int timeoutInMinutes);
        /// <summary>
        /// (Warning) - [{pipDescription}] The following processes '{exePath}' require ptrace and their file accesses may not be reported by the sandbox.
        /// </summary>
        void LinuxSandboxReportedBinaryRequiringPTrace(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath);
        /// <summary>
        /// (Verbose) - [{pipDescription}] Ptrace sandbox was launched for the following processes '{exePath}'.
        /// </summary>
        void PTraceSandboxLaunchedForPip(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath);
        /// <summary>
        /// (Verbose) - [{pipDescription}] Process {pid} with path '{exePath}' breaks away from the sandbox.
        /// </summary>
        void ProcessBreakaway(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath, uint pid);
        /// <summary>
        /// (Error) - [{pipDescription}] PTraceRunner logged the following error: {content}
        /// </summary>
        void PTraceRunnerError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string content);
        /// <summary>
        /// (Verbose) - [{pipDescription}] Received ProcessCommandLine report without a matching ProcessStart report for pid '{pid}'.
        /// </summary>
        void ReportArgsMismatch(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid);
        /// <summary>
        /// (Verbose) - [{pipDescription}] Received report from unknown pid: {pid}
        /// </summary>
        void ReceivedReportFromUnknownPid(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid);
        /// <summary>
        /// (Verbose) - The following file access occurred before the BxlObserver was able to complete initialization '{path}'
        /// </summary>
        void ReceivedFileAccessReportBeforeSemaphoreInit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string path);
        /// <summary>
        /// (Error) - Could not prepare environment variables. Error: {error}
        /// </summary>
        void EnvironmentPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext logging, string error);
    }

    /// <summary>
    /// Instance based logger
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("csc.exe", "4.1100.24.46003")]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public class Log
    {
        /// <summary>
        /// The static logger this delegates to
        /// </summary>
        private Logger m_logger;
        /// <summary>
        /// The logging context to use.
        /// </summary>
        public global::BuildXL.Utilities.Instrumentation.Common.LoggingContext LoggingContext { get; }

        /// <summary>
        /// Creates a new instnce base logger.
        /// </summary>
        public Log(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, bool preserveLogEvents = false)
        {
            m_logger = Logger.CreateLogger(preserveLogEvents);
            LoggingContext = loggingContext;
        }

        /// <summary>
        /// Verbose DX0010: [{1}] File access on '{3}' with {2}
        /// </summary>
        public void PipProcessFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
        {
            m_logger.PipProcessFileAccess(context, pipSemiStableHash, pipDescription, fileAccessDescription, path);
        }

        /// <summary>
        /// Error DX0308: [{1}] Process created a symlink at '{2}'. Symlink outputs are not currently supported. This error was introduced by /FailSymlinkCreationflag.
        /// </summary>
        public void PipFailSymlinkCreation(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
        {
            m_logger.PipFailSymlinkCreation(context, pipSemiStableHash, pipDescription, path);
        }

        /// <summary>
        /// Error DX0023: A debug {ShortProductName} is using a non-debug DetoursServices.dll.
        /// </summary>
        public void PipInvalidDetoursDebugFlag1(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
        {
            m_logger.PipInvalidDetoursDebugFlag1(context);
        }

        /// <summary>
        /// Error DX0024: A non-debug {ShortProductName} is using a debug DetoursServices.dll.
        /// </summary>
        public void PipInvalidDetoursDebugFlag2(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
        {
            m_logger.PipInvalidDetoursDebugFlag2(context);
        }

        /// <summary>
        /// Warning DX0011: [{1}] Process start failed with error code {2:X8}: {3}. Pip may be retried or failed.
        /// </summary>
        public void PipProcessStartFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string message)
        {
            m_logger.PipProcessStartFailed(context, pipSemiStableHash, pipDescription, errorCode, message);
        }

        /// <summary>
        /// Error DX0014: [{1}] Process start failed with error code {2:X8}: File '{3}' was not found on disk. The tool is referred to in '{4}({5})'.
        /// </summary>
        public void PipProcessFileNotFound(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string filename, string specFile, int position)
        {
            m_logger.PipProcessFileNotFound(context, pipSemiStableHash, pipDescription, errorCode, filename, specFile, position);
        }

        /// <summary>
        /// Verbose DX0012: [{1}] Process exited cleanly with exit code {2}
        /// </summary>
        public void PipProcessFinished(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
        {
            m_logger.PipProcessFinished(context, pipSemiStableHash, pipDescription, exitCode);
        }

        /// <summary>
        /// Verbose DX0013: [{1}] Process failed with exit code {2}
        /// </summary>
        public void PipProcessFinishedFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
        {
            m_logger.PipProcessFinishedFailed(context, pipSemiStableHash, pipDescription, exitCode);
        }

        /// <summary>
        /// Error DX0311: [{1}] Process failed with message parsing error: {2}.
        /// </summary>
        public void PipProcessMessageParsingError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string error)
        {
            m_logger.PipProcessMessageParsingError(context, pipSemiStableHash, pipDescription, error);
        }

        /// <summary>
        /// Error DX0026: [{1}] Failed to instrument one or more processes
        /// </summary>
        public void PipProcessFinishedDetourFailures(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
        {
            m_logger.PipProcessFinishedDetourFailures(context, pipSemiStableHash, pipDescription);
        }

        /// <summary>
        /// Verbose DX0020: [{1}] Disallowed file access in temp directory was blocked on '{3}' with {2}; declare that this pip needs a temp directory.
        /// </summary>
        public void PipProcessDisallowedTempFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
        {
            m_logger.PipProcessDisallowedTempFileAccess(context, pipSemiStableHash, pipDescription, fileAccessDescription, path);
        }

        /// <summary>
        /// Verbose DX2603: [{1}] No file access for output: {2}. Detours discovered inconsistency in detouring some child processes. Information about the inconsistency can be found in the BuildXL log file. Please, restart the build...
        /// </summary>
        public void PipOutputNotAccessed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string outputFileName)
        {
            m_logger.PipOutputNotAccessed(context, pipSemiStableHash, pipDescription, outputFileName);
        }

        /// <summary>
        /// Verbose DX0009: [{1}, {2}, {3}] - Disallowed file access was detected on '{5}' with {4}.
        /// </summary>
        public void PipProcessDisallowedFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
        {
            m_logger.PipProcessDisallowedFileAccess(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
        }

        /// <summary>
        /// Warning DX0480: [{1}, {2}, {3}] - Disallowed NtCreateFile access was detected on '{5}' with {4}. This warning will become an error if the '/unsafe_ignoreNtCreateFile+' is removed.
        /// </summary>
        public void PipProcessDisallowedNtCreateFileAccessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
        {
            m_logger.PipProcessDisallowedNtCreateFileAccessWarning(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
        }

        /// <summary>
        /// Warning DX0015: [{1}] Process ran for {2}ms, which is longer than the warning timeout of {3}ms; the process will be terminated if it ever runs longer than {4}ms
        /// </summary>
        public void PipProcessTookTooLongWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long softMax, long hardMax)
        {
            m_logger.PipProcessTookTooLongWarning(context, pipSemiStableHash, pipDescription, actual, softMax, hardMax);
        }

        /// <summary>
        /// Error DX0016: [{1}] Process terminated because it took too long: {2}ms; the timeout is set to {3}ms. {4} \r\n Process Output: \r\n {5}
        /// </summary>
        public void PipProcessTookTooLongError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long time, string dumpDetails, string outputToLog)
        {
            m_logger.PipProcessTookTooLongError(context, pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog);
        }

        /// <summary>
        /// Verbose DX0017: [{1}] Process standard output at '{2}'
        /// </summary>
        public void PipProcessStandardOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
        {
            m_logger.PipProcessStandardOutput(context, pipSemiStableHash, pipDescription, path);
        }

        /// <summary>
        /// Verbose DX0018: [{1}] Process standard error at '{2}'
        /// </summary>
        public void PipProcessStandardError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
        {
            m_logger.PipProcessStandardError(context, pipSemiStableHash, pipDescription, path);
        }

        /// <summary>
        /// Verbose DX0022: [{1}] File access table entry '{2}'
        /// </summary>
        public void PipProcessFileAccessTableEntry(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string value)
        {
            m_logger.PipProcessFileAccessTableEntry(context, pipSemiStableHash, pipDescription, value);
        }

        /// <summary>
        /// Warning DX0802: [{1}] Access to the following path will be ignored, since the path could not be parsed: '{3}' (Accessed via {2})
        /// </summary>
        public void PipProcessFailedToParsePathOfFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            m_logger.PipProcessFailedToParsePathOfFileAccess(context, pipSemiStableHash, pipDescription, operation, path);
        }

        /// <summary>
        /// Verbose DX0801: [{1}] Access to the following path will be ignored, since the path is a path to a device: '{3}' (Accessed via {2})
        /// </summary>
        public void PipProcessIgnoringPathOfSpecialDeviceFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            m_logger.PipProcessIgnoringPathOfSpecialDeviceFileAccess(context, pipSemiStableHash, pipDescription, operation, path);
        }

        /// <summary>
        /// Verbose DX0800: [{1}] Access to the following path will be ignored, since the path contains wildcard characters: '{3}' (Accessed via {2})
        /// </summary>
        public void PipProcessIgnoringPathWithWildcardsFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            m_logger.PipProcessIgnoringPathWithWildcardsFileAccess(context, pipSemiStableHash, pipDescription, operation, path);
        }

        /// <summary>
        /// Verbose DX0269: [{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.
        /// </summary>
        public void PipProcessDisallowedFileAccessAllowlistedNonCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            m_logger.PipProcessDisallowedFileAccessAllowlistedNonCacheable(context, pipSemiStableHash, pipDescription, processPath, path);
        }

        /// <summary>
        /// Verbose DX0264: [{1}] Disallowed file access (cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.
        /// </summary>
        public void PipProcessDisallowedFileAccessAllowlistedCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            m_logger.PipProcessDisallowedFileAccessAllowlistedCacheable(context, pipSemiStableHash, pipDescription, processPath, path);
        }

        /// <summary>
        /// Warning DX0274: [{1}] Failed to parse tool path '{3}' at character '{4}' that accessed '{2}'. File access allowlist entries matching on tool paths will not be checked for this access.
        /// </summary>
        public void FileAccessAllowlistFailedToParsePath(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string processPath, int characterWithError)
        {
            m_logger.FileAccessAllowlistFailedToParsePath(context, pipSemiStableHash, pipDescription, path, processPath, characterWithError);
        }

        /// <summary>
        /// Error DX4401: [{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message is an error because non-cacheable allowlist matches are not allowed in distributed builds.
        /// </summary>
        public void PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            m_logger.PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(context, pipSemiStableHash, pipDescription, processPath, path);
        }

        /// <summary>
        /// Verbose DX0803: [{1}] Process with id {2} at '{3}'
        /// </summary>
        public void PipProcess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint id, string path)
        {
            m_logger.PipProcess(context, pipSemiStableHash, pipDescription, id, path);
        }

        /// <summary>
        /// Error DX10100: Failed to instrument process ID {0} for file monitoring on behalf of an existing instrumented process, error: {1}. Most likely reason for this error is the run time for the process exceeded the allowed timeout for the process to complete.
        /// </summary>
        public void BrokeredDetoursInjectionFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, uint processId, string error)
        {
            m_logger.BrokeredDetoursInjectionFailed(context, processId, error);
        }

        /// <summary>
        /// Verbose DX10101: [Pip{pipSemiStableHash:X16}] Detours Debug Message: {message}
        /// </summary>
        public void LogDetoursDebugMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string message)
        {
            m_logger.LogDetoursDebugMessage(context, pipSemiStableHash, message);
        }

        /// <summary>
        /// Verbose DX12500: Find AnyBuild client for process remoting at '{anyBuildInstallDir}'
        /// </summary>
        public void FindAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string anyBuildInstallDir)
        {
            m_logger.FindAnyBuildClient(context, anyBuildInstallDir);
        }

        /// <summary>
        /// Verbose DX12501: Find or start AnyBuild daemon manager for process remoting with arguments '{args}' (log directory: '{logDir}')
        /// </summary>
        public void FindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string args, string logDir)
        {
            m_logger.FindOrStartAnyBuildDaemon(context, args, logDir);
        }

        /// <summary>
        /// Warning DX12504: Exception on finding or starting AnyBuild daemon: {exception}
        /// </summary>
        public void ExceptionOnFindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
        {
            m_logger.ExceptionOnFindOrStartAnyBuildDaemon(context, exception);
        }

        /// <summary>
        /// Warning DX12505: Exception on getting AnyBuild remote process factory: {exception}
        /// </summary>
        public void ExceptionOnGetAnyBuildRemoteProcessFactory(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
        {
            m_logger.ExceptionOnGetAnyBuildRemoteProcessFactory(context, exception);
        }

        /// <summary>
        /// Warning DX12512: Exception on finding AnyBuild client: {exception}
        /// </summary>
        public void ExceptionOnFindingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
        {
            m_logger.ExceptionOnFindingAnyBuildClient(context, exception);
        }

        /// <summary>
        /// Verbose DX12513: AnyBuild repo config overrides: {config}
        /// </summary>
        public void AnyBuildRepoConfigOverrides(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string config)
        {
            m_logger.AnyBuildRepoConfigOverrides(context, config);
        }

        /// <summary>
        /// Informational DX12506: Installing AnyBuild client from '{source}' (ring: {ring})
        /// </summary>
        public void InstallAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring)
        {
            m_logger.InstallAnyBuildClient(context, source, ring);
        }

        /// <summary>
        /// Verbose DX12511: Installing AnyBuild client from '{source}' (ring: {ring}): {reason}
        /// </summary>
        public void InstallAnyBuildClientDetails(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring, string reason)
        {
            m_logger.InstallAnyBuildClientDetails(context, source, ring, reason);
        }

        /// <summary>
        /// Warning DX12507: Failed downloading AnyBuild client: {message}
        /// </summary>
        public void FailedDownloadingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
        {
            m_logger.FailedDownloadingAnyBuildClient(context, message);
        }

        /// <summary>
        /// Warning DX12508: Failed installing AnyBuild client: {message}
        /// </summary>
        public void FailedInstallingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
        {
            m_logger.FailedInstallingAnyBuildClient(context, message);
        }

        /// <summary>
        /// Verbose DX12509: Finished installing AnyBuild client: {message}
        /// </summary>
        public void FinishedInstallAnyBuild(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
        {
            m_logger.FinishedInstallAnyBuild(context, message);
        }

        /// <summary>
        /// Verbose DX12510: Execute AnyBuild bootstrapper: {command}
        /// </summary>
        public void ExecuteAnyBuildBootstrapper(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string command)
        {
            m_logger.ExecuteAnyBuildBootstrapper(context, command);
        }

        /// <summary>
        /// Verbose DX10102: [{1}] Apple sandbox-exec policy for pip generated: {policyFilePath}
        /// </summary>
        public void LogAppleSandboxPolicyGenerated(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string policyFilePath)
        {
            m_logger.LogAppleSandboxPolicyGenerated(context, pipSemiStableHash, pipDescription, policyFilePath);
        }

        /// <summary>
        /// Verbose DX2928: [{1}] Maximum detours heap size for process in the pip is {maxDetoursHeapSizeInBytes} bytes. The processName '{processName}'. The processId is: {processId}. The manifestSize in bytes is: {manifestSizeInBytes}. The finalDetoursHeapSize in bytes is: {finalDetoursHeapSizeInBytes}. The allocatedPoolEntries is: {allocatedPoolEntries}. The maxHandleMapEntries is: {maxHandleMapEntries}. The handleMapEntries is: {handleMapEntries}.
        /// </summary>
        public void LogDetoursMaxHeapSize(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, ulong maxDetoursHeapSizeInBytes, string processName, uint processId, uint manifestSizeInBytes, ulong finalDetoursHeapSizeInBytes, uint allocatedPoolEntries, ulong maxHandleMapEntries, ulong handleMapEntries)
        {
            m_logger.LogDetoursMaxHeapSize(context, pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries);
        }

        /// <summary>
        /// Error DX2919: [{1}] Detoured process emitted failure information that could not be transmitted back to {ShortProductName}. Diagnostic file content: {2}
        /// </summary>
        public void LogInternalDetoursErrorFileNotEmpty(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
        {
            m_logger.LogInternalDetoursErrorFileNotEmpty(context, pipSemiStableHash, pipDescription, message);
        }

        /// <summary>
        /// Error DX2925: [{1}] Failed to create directory for the internal Detours error file. Path: {path}. Error: {message}
        /// </summary>
        public void LogFailedToCreateDirectoryForInternalDetoursFailureFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string message)
        {
            m_logger.LogFailedToCreateDirectoryForInternalDetoursFailureFile(context, pipSemiStableHash, pipDescription, path, message);
        }

        /// <summary>
        /// Error DX2920: [{1}] Failed checking for detours backup communication file existence. Pip will be treated as a failure. Error: {message}.
        /// </summary>
        public void LogGettingInternalDetoursErrorFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
        {
            m_logger.LogGettingInternalDetoursErrorFile(context, pipSemiStableHash, pipDescription, message);
        }

        /// <summary>
        /// Verbose DX2927: [{1}] The number of messages sent successfully by detoured processes did not match the number received by the {MainExecutableName} process, which indicates lost messages. {MainExecutableName} cannot reliably use the file accesses reported by Detours for caching the process pip. LostMessageCount: {lastConfirmedMessageCount}
        /// </summary>
        public void LogMismatchedDetoursCountLostMessages(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
        {
            m_logger.LogMismatchedDetoursCountLostMessages(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
        }

        /// <summary>
        /// Verbose DX14301: [{1}] The number of messages sent by detoured processes did not match the number received by the {MainExecutableName} process, which indicates that calls to detoured APIs terminated abruptly, and indicates that the detoured processes could have a non-deterministic file access behavior. This can cause the process pip to be cached with different sets of file accesses as cache keys. DiffBetweenSendAttemptsAndReceived: {lastMessageCount}. LostMessageCount: {lastConfirmedMessageCount} (&lt;= 0 means no lost message).
        /// </summary>
        public void LogMismatchedDetoursCount(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
        {
            m_logger.LogMismatchedDetoursCount(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
        }

        /// <summary>
        /// Error DX2923: [{1}] Can't open semaphore for counting Detours messages. Full failure message: {2}
        /// </summary>
        public void LogMessageCountSemaphoreOpenFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string failureMessage)
        {
            m_logger.LogMessageCountSemaphoreOpenFailure(context, pipSemiStableHash, pipDescription, failureMessage);
        }

        /// <summary>
        /// Error DX0032: [{1}] Process command line is longer than {3} characters: {2}
        /// </summary>
        public void PipProcessCommandLineTooLong(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string commandLine, int maxLength)
        {
            m_logger.PipProcessCommandLineTooLong(context, pipSemiStableHash, pipDescription, commandLine, maxLength);
        }

        /// <summary>
        /// Error DX0039: [{1}] Process warning regular expression is invalid, pattern is {2}, options are {3}
        /// </summary>
        public void PipProcessInvalidWarningRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
        {
            m_logger.PipProcessInvalidWarningRegex(context, pipSemiStableHash, pipDescription, pattern, options);
        }

        /// <summary>
        /// Error DX0089: [{1}] Process error regular expression is invalid, pattern is {2}, options are {3}
        /// </summary>
        public void PipProcessInvalidErrorRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
        {
            m_logger.PipProcessInvalidErrorRegex(context, pipSemiStableHash, pipDescription, pattern, options);
        }

        /// <summary>
        /// Error DX0041: [{1}] Unexpected child processes survived: {2} process(es){3}
        /// </summary>
        public void PipProcessChildrenSurvivedError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
        {
            m_logger.PipProcessChildrenSurvivedError(context, pipSemiStableHash, pipDescription, count, paths);
        }

        /// <summary>
        /// Verbose DX0043: [{1}] Too many child processes survived: {2} process(es){3}
        /// </summary>
        public void PipProcessChildrenSurvivedTooMany(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
        {
            m_logger.PipProcessChildrenSurvivedTooMany(context, pipSemiStableHash, pipDescription, count, paths);
        }

        /// <summary>
        /// Verbose DX0042: [{1}] Process and/or job containing child processes killed
        /// </summary>
        public void PipProcessChildrenSurvivedKilled(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
        {
            m_logger.PipProcessChildrenSurvivedKilled(context, pipSemiStableHash, pipDescription);
        }

        /// <summary>
        /// Verbose DX0044: [{1}, {2}, {3}]Process was expected to write an output file at '{4}', but that file is not present.
        /// </summary>
        public void PipProcessMissingExpectedOutputOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string path)
        {
            m_logger.PipProcessMissingExpectedOutputOnCleanExit(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path);
        }

        /// <summary>
        /// Error DX0045: [{1}, {2}, {3}]Process exited succesfully but wrote to standard error. The process is configured to fail in this case, even if the exit code was successful.
        /// </summary>
        public void PipProcessWroteToStandardErrorOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory)
        {
            m_logger.PipProcessWroteToStandardErrorOnCleanExit(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory);
        }

        /// <summary>
        /// Error DX0504: [{1}] - Process was expected to write the following output files, but those files are not present.:\r\n{2}
        /// </summary>
        public void PipProcessExpectedMissingOutputs(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string paths)
        {
            m_logger.PipProcessExpectedMissingOutputs(context, pipSemiStableHash, pipDescription, paths);
        }

        /// <summary>
        /// Error DX0046: [{1}, {2}, {3}]Process output directories could not be prepared, path '{2}', error code {3:X8}: {4}
        /// </summary>
        public void PipProcessOutputPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message, string exception)
        {
            m_logger.PipProcessOutputPreparationFailed(context, pipSemiStableHash, pipDescription, path, errorCode, message, exception);
        }

        /// <summary>
        /// Verbose DX0047: [{1}] Process output '{2}' could not be prepared. Attempting to delete it from within the VM on the next retry.
        /// </summary>
        public void PipProcessOutputPreparationToBeRetriedInVM(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
        {
            m_logger.PipProcessOutputPreparationToBeRetriedInVM(context, pipSemiStableHash, pipDescription, path);
        }

        /// <summary>
        /// Error DX0316: [{1}] Process standard I/O failure at path '{2}', error code {3:X8}: {4}
        /// </summary>
        public void PipStandardIOFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            m_logger.PipStandardIOFailed(context, pipSemiStableHash, pipDescription, path, errorCode, message);
        }

        /// <summary>
        /// Verbose DX0314: [{1}] Pip had unclean exit. Canceled: {canceled}, Error code {errorCode}, Killed: {killed}, # Surviving child errors: {numSurvivingChildErrors}
        /// </summary>
        public void PipExitedUncleanly(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool canceled, int errorCode, bool killed, int numSurvivingChildErrors)
        {
            m_logger.PipExitedUncleanly(context, pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors);
        }

        /// <summary>
        /// Verbose DX0317: [{1}] Pip will be retried because its reported process '{process}' with pid '{processId}' exited with Azure Watson's 0xDEAD exit code
        /// </summary>
        public void PipRetryDueToExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, uint processId)
        {
            m_logger.PipRetryDueToExitedWithAzureWatsonExitCode(context, pipSemiStableHash, pipDescription, process, processId);
        }

        /// <summary>
        /// Warning DX0319: [{1}] Pip finished with some process (can be a child process) '{process} {args}' with pid '{processId}' exited with Azure Watson's 0xDEAD exit code. Pip will not be cached if warning is treated as an error.
        /// </summary>
        public void PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, string args, uint processId)
        {
            m_logger.PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(context, pipSemiStableHash, pipDescription, process, args, processId);
        }

        /// <summary>
        /// Verbose DX0086: [{1}, {2}, {3}] Unexpected standard input exception: {4}
        /// </summary>
        public void PipProcessStandardInputException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string exceptionMessage)
        {
            m_logger.PipProcessStandardInputException(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage);
        }

        /// <summary>
        /// Error DX14300: [{1}, {2}, {3}]The tool '{toolName}' cannot access the file '{file}' because it is being used by another process: \r\n{reason}
        /// </summary>
        public void PipProcessToolErrorDueToHandleToFileBeingUsed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string toolName, string file, string reason)
        {
            m_logger.PipProcessToolErrorDueToHandleToFileBeingUsed(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason);
        }

        /// <summary>
        /// Error DX0064: [{1}, {2}, {3}] - failed with exit code {exitCode}{optionalMessage}\r\n{outputToLog}\r\n{messageAboutPathsToLog}\r\n{pathsToLog}
        /// </summary>
        public void PipProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog, int exitCode, string optionalMessage, string shortPipDescription, long pipExecutionTimeMs)
        {
            m_logger.PipProcessError(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs);
        }

        /// <summary>
        /// Warning DX0065: [{1}, {2}, {3}] - warnings\r\n{outputToLog}\r\n{messageAboutPathsToLog}\r\n{pathsToLog}
        /// </summary>
        public void PipProcessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog)
        {
            m_logger.PipProcessWarning(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog);
        }

        /// <summary>
        /// Verbose DX0066: [{1}, {2}, {3}]\r\n{4}
        /// </summary>
        public void PipProcessOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string outputToLog)
        {
            m_logger.PipProcessOutput(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog);
        }

        /// <summary>
        /// Warning DX2201: [{1}] Failed to clean temp directory at '{directory}'. Pip may be retried or failed. {exceptionMessage}
        /// </summary>
        public void PipTempDirectoryCleanupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
        {
            m_logger.PipTempDirectoryCleanupFailure(context, pipSemiStableHash, pipDescription, directory, exceptionMessage);
        }

        /// <summary>
        /// Warning DX2203: [{1}] Failed to create temp directory at '{directory}'. Pip may be retried or failed. {exceptionMessage}
        /// </summary>
        public void PipTempDirectorySetupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
        {
            m_logger.PipTempDirectorySetupFailure(context, pipSemiStableHash, pipDescription, directory, exceptionMessage);
        }

        /// <summary>
        /// Error DX2205: [{1}] Failed to create directory symlink '{directorySymlink}' as a redirection for temp directory '{tempDirectory}'. {exceptionMessage}
        /// </summary>
        public void PipTempSymlinkRedirectionError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory, string exceptionMessage)
        {
            m_logger.PipTempSymlinkRedirectionError(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage);
        }

        /// <summary>
        /// Verbose DX2206: [{1}] Create directory symlink '{directorySymlink}' as a redirection for temp directory '{tempDirectory}'
        /// </summary>
        public void PipTempSymlinkRedirection(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory)
        {
            m_logger.PipTempSymlinkRedirection(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory);
        }

        /// <summary>
        /// Warning DX2210: [{1}] Failed to create dump for timed out process. {exceptionMessage}
        /// </summary>
        public void PipFailedToCreateDumpFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string exceptionMessage)
        {
            m_logger.PipFailedToCreateDumpFile(context, pipSemiStableHash, pipDescription, exceptionMessage);
        }

        /// <summary>
        /// Verbose DX0085: [{1}, {2}, {3}]Retry to start pip for {retryNumber} time(s) due to the following error: {error}
        /// </summary>
        public void RetryStartPipDueToErrorPartialCopyDuringDetours(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int error, int retryNumber)
        {
            m_logger.RetryStartPipDueToErrorPartialCopyDuringDetours(context, pipSemiStableHash, pipDescription, error, retryNumber);
        }

        /// <summary>
        /// Warning DX0336: Unexpected duplicate environment variable encountered. Variable '{0}' has already been defined with value '{1}'. The other occurrence with value '{2}' will be ignored.
        /// </summary>
        public void DuplicateWindowsEnvironmentVariableEncountered(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string key, string existingValue, string ignoredValue)
        {
            m_logger.DuplicateWindowsEnvironmentVariableEncountered(context, key, existingValue, ignoredValue);
        }

        /// <summary>
        /// Verbose DX0019: [{1}] File access on file '{3}' requested with Read/Write but granted for Read only by process with ID: {2}.
        /// </summary>
        public void ReadWriteFileAccessConvertedToReadMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint processId, string path)
        {
            m_logger.ReadWriteFileAccessConvertedToReadMessage(context, pipSemiStableHash, pipDescription, processId, path);
        }

        /// <summary>
        /// Warning DX0021: [{1}] This pip might have failed because of converting Read/Write file access to a Read file access. Examine the execution log for information on which files the Read/Write access request was converted to Read access request.
        /// </summary>
        public void ReadWriteFileAccessConvertedToReadWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
        {
            m_logger.ReadWriteFileAccessConvertedToReadWarning(context, pipSemiStableHash, pipDescription);
        }

        /// <summary>
        /// Error DX0074: [{1}, {2}, {3}]Process response file could not be prepared, path '{2}', error code {3:X8}: {4}
        /// </summary>
        public void PipProcessResponseFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            m_logger.PipProcessResponseFileCreationFailed(context, pipSemiStableHash, pipDescription, path, errorCode, message);
        }

        /// <summary>
        /// Verbose DX0053: [{1}] Failed to preserve output directory '{directory}' because '{file}' cannot be made private, contents of the directory will be deleted
        /// </summary>
        public void PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string file)
        {
            m_logger.PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(context, pipSemiStableHash, pipDescription, directory, file);
        }

        /// <summary>
        /// Verbose DX0054: [{1}] Output directory '{directory}' is not preserved because /unsafe_IgnorePreserveOutputsPrivatization. This can cause failure in pip execution.
        /// </summary>
        public void PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory)
        {
            m_logger.PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(context, pipSemiStableHash, pipDescription, directory);
        }

        /// <summary>
        /// Error DX0090: [{1}] File containing change affected inputs could not be prepared, path '{path}', error code {errorCode:X8}: {message}
        /// </summary>
        public void PipProcessChangeAffectedInputsWrittenFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            m_logger.PipProcessChangeAffectedInputsWrittenFileCreationFailed(context, pipSemiStableHash, pipDescription, path, errorCode, message);
        }

        /// <summary>
        /// Error DX12209: [{1}] Cannot create a hardlink from '{sourceFile}' to '{destinationFile}' when merging outputs to their original location: {failedStatus}
        /// </summary>
        internal void FailedToCreateHardlinkOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile, string failedStatus)
        {
            m_logger.FailedToCreateHardlinkOnMerge(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus);
        }

        /// <summary>
        /// Error DX12211: [{1}] A disallowed double write was detected when merging '{sourceFile}' to '{destinationFile}'.
        /// </summary>
        internal void DisallowedDoubleWriteOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile)
        {
            m_logger.DisallowedDoubleWriteOnMerge(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile);
        }

        /// <summary>
        /// Verbose DX12210: [{1}] Detected double write in '{destinationFile}' when merging outputs to their original location. The double write is allowed due to configured policy.
        /// </summary>
        internal void DoubleWriteAllowedDueToPolicy(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile)
        {
            m_logger.DoubleWriteAllowedDueToPolicy(loggingContext, pipSemiStableHash, pipDescription, destinationFile);
        }

        /// <summary>
        /// Verbose DX0078: [{1}] Process execution via external tool '{tool}' starts
        /// </summary>
        public void PipProcessStartExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
        {
            m_logger.PipProcessStartExternalTool(context, pipSemiStableHash, pipDescription, tool);
        }

        /// <summary>
        /// Verbose DX0079: [{1}] Process execution via external tool finished with the tool's exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        public void PipProcessFinishedExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            m_logger.PipProcessFinishedExternalTool(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
        }

        /// <summary>
        /// Verbose DX12502: [{1}] Remoting process execution via '{tool}' starts
        /// </summary>
        public void PipProcessStartRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
        {
            m_logger.PipProcessStartRemoteExecution(context, pipSemiStableHash, pipDescription, tool);
        }

        /// <summary>
        /// Verbose DX12503: [{1}] Remoting process execution via external tool finished with the tool's exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        public void PipProcessFinishedRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            m_logger.PipProcessFinishedRemoteExecution(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
        }

        /// <summary>
        /// Verbose DX0080: [{1}] Process execution in VM starts
        /// </summary>
        public void PipProcessStartExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
        {
            m_logger.PipProcessStartExternalVm(context, pipSemiStableHash, pipDescription);
        }

        /// <summary>
        /// Verbose DX0081: [{1}] Process execution in VM finished with VM's command proxy exit code {exitCode}:{stdOut}{stdErr}
        /// </summary>
        public void PipProcessFinishedExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            m_logger.PipProcessFinishedExternalVm(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
        }

        /// <summary>
        /// Verbose DX0082: [{1}] External execution: {message}
        /// </summary>
        public void PipProcessExternalExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
        {
            m_logger.PipProcessExternalExecution(context, pipSemiStableHash, pipDescription, message);
        }

        /// <summary>
        /// Warning DX0092: [{1}] Process needs to be executed externally because (require admin privilege: {requiredAdminPrivilege} | execution mode: {executionMode}), but instead it executes internally because (Win OS: {isWinOS} | listener existence: {existsListener})
        /// </summary>
        public void PipProcessNeedsExecuteExternalButExecuteInternal(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool requiredAdminPrivilege, string executionMode, bool isWinOS, bool existsListener)
        {
            m_logger.PipProcessNeedsExecuteExternalButExecuteInternal(context, pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener);
        }

        /// <summary>
        /// Verbose DX0093: [{pipSemiStableHash}] Done with phase '{phaseName}' in {duration}.  {extraInfo}
        /// </summary>
        public void LogPhaseDuration(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string phaseName, string duration, string extraInfo)
        {
            m_logger.LogPhaseDuration(context, pipSemiStableHash, phaseName, duration, extraInfo);
        }

        /// <summary>
        /// Error DX0877: [{pipDescription}] Failed to delete shared opaque output files recorded in '{sidebandFile}':{files}.  Reason: {failure}
        /// </summary>
        public void CannotDeleteSharedOpaqueOutputFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, string failure)
        {
            m_logger.CannotDeleteSharedOpaqueOutputFile(context, pipDescription, sidebandFile, files, failure);
        }

        /// <summary>
        /// Verbose DX0874: [{pipDescription}] Lazily deleted {count} shared opaque output files recorded in '{sidebandFile}':{files}.
        /// </summary>
        public void SharedOpaqueOutputsDeletedLazily(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, int count)
        {
            m_logger.SharedOpaqueOutputsDeletedLazily(context, pipDescription, sidebandFile, files, count);
        }

        /// <summary>
        /// Error DX0875: Cannot read sideband file '{fileName}': {error}
        /// </summary>
        public void CannotReadSidebandFileError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
        {
            m_logger.CannotReadSidebandFileError(context, fileName, error);
        }

        /// <summary>
        /// Warning DX0876: Cannot read sideband file '{fileName}': {error}
        /// </summary>
        public void CannotReadSidebandFileWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
        {
            m_logger.CannotReadSidebandFileWarning(context, fileName, error);
        }

        /// <summary>
        /// Verbose DX0878: [{pipSemiStableHash}] occurred an error for {failedOperation}: {errorCode}
        /// </summary>
        public void ResumeOrSuspendProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string failedOperation, int errorCode)
        {
            m_logger.ResumeOrSuspendProcessError(context, pipSemiStableHash, failedOperation, errorCode);
        }

        /// <summary>
        /// Verbose DX0879: {operation} attempt failed with exception. {exception}
        /// </summary>
        public void ResumeOrSuspendException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string operation, string exception)
        {
            m_logger.ResumeOrSuspendException(context, operation, exception);
        }

        /// <summary>
        /// Error DX0275: [{pipDescription}] Failed to probe '{path}' under a shared opaque directory : {details}
        /// </summary>
        public void CannotProbeOutputUnderSharedOpaque(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string path, string details)
        {
            m_logger.CannotProbeOutputUnderSharedOpaque(context, pipDescription, path, details);
        }

        /// <summary>
        /// Verbose DX12213: [{1}] Failure during dumping unexpected surviving child processes for Process: '{processName}'. Status: {status}
        /// </summary>
        public void DumpSurvivingPipProcessChildrenStatus(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string processName, string status)
        {
            m_logger.DumpSurvivingPipProcessChildrenStatus(context, processName, status);
        }

        /// <summary>
        /// Error DX12214: [{pipDescription}] The output file '{assertedOutput}' existence was asserted under output directory root '{outputDirectoryRoot}' but the file was not produced by the pip.
        /// </summary>
        public void ExistenceAssertionUnderOutputDirectoryFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string assertedOutput, string outputDirectoryRoot)
        {
            m_logger.ExistenceAssertionUnderOutputDirectoryFailed(context, pipDescription, assertedOutput, outputDirectoryRoot);
        }

        /// <summary>
        /// Warning DX12514: [{pipSemiStableHash}] Logging process StandardOutput/StandardError timed out after exceeding '{timeoutInMinutes}' minutes. This may be caused by the default terminal being Windows Terminal, workaround this by switching the default terminal to 'Windows Console Host' in Windows settings or Windows Terminal settings. Output streams may be incomplete due to this error.
        /// </summary>
        public void SandboxedProcessResultLogOutputTimeout(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, int timeoutInMinutes)
        {
            m_logger.SandboxedProcessResultLogOutputTimeout(context, pipSemiStableHash, timeoutInMinutes);
        }

        /// <summary>
        /// Warning DX10104: [{pipDescription}] The following processes '{exePath}' require ptrace and their file accesses may not be reported by the sandbox.
        /// </summary>
        public void LinuxSandboxReportedBinaryRequiringPTrace(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
        {
            m_logger.LinuxSandboxReportedBinaryRequiringPTrace(context, pipDescription, exePath);
        }

        /// <summary>
        /// Verbose DX10106: [{pipDescription}] Ptrace sandbox was launched for the following processes '{exePath}'.
        /// </summary>
        public void PTraceSandboxLaunchedForPip(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
        {
            m_logger.PTraceSandboxLaunchedForPip(context, pipDescription, exePath);
        }

        /// <summary>
        /// Verbose DX14303: [{pipDescription}] Process {pid} with path '{exePath}' breaks away from the sandbox.
        /// </summary>
        public void ProcessBreakaway(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath, uint pid)
        {
            m_logger.ProcessBreakaway(context, pipDescription, exePath, pid);
        }

        /// <summary>
        /// Error DX10105: [{pipDescription}] PTraceRunner logged the following error: {content}
        /// </summary>
        internal void PTraceRunnerError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string content)
        {
            m_logger.PTraceRunnerError(loggingContext, pipDescription, content);
        }

        /// <summary>
        /// Verbose DX10107: [{pipDescription}] Received ProcessCommandLine report without a matching ProcessStart report for pid '{pid}'.
        /// </summary>
        internal void ReportArgsMismatch(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
        {
            m_logger.ReportArgsMismatch(loggingContext, pipDescription, pid);
        }

        /// <summary>
        /// Verbose DX10108: [{pipDescription}] Received report from unknown pid: {pid}
        /// </summary>
        internal void ReceivedReportFromUnknownPid(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
        {
            m_logger.ReceivedReportFromUnknownPid(loggingContext, pipDescription, pid);
        }

        /// <summary>
        /// Verbose DX10109: The following file access occurred before the BxlObserver was able to complete initialization '{path}'
        /// </summary>
        internal void ReceivedFileAccessReportBeforeSemaphoreInit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string path)
        {
            m_logger.ReceivedFileAccessReportBeforeSemaphoreInit(loggingContext, path);
        }

        /// <summary>
        /// Error DX14302: Could not prepare environment variables. Error: {error}
        /// </summary>
        public void EnvironmentPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext logging, string error)
        {
            m_logger.EnvironmentPreparationFailed(logging, error);
        }
    }

    /// <summary>
    /// Logging Instantiation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("csc.exe", "4.1100.24.46003")]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public partial class Logger : global::BuildXL.Utilities.Instrumentation.Common.LoggerBase
    {
        static private Logger m_log = new LoggerImpl();
        /// <summary>
        /// Factory method that creates instances of the logger.
        /// </summary>
        public static Logger CreateLogger(bool preserveLogEvents = false)
        {
            return new LoggerImpl
            {
                PreserveLogEvents = preserveLogEvents,
                InspectMessageEnabled = preserveLogEvents,
            };
        }

        /// <summary>
        /// Factory method that creates instances of the logger that tracks errors and allows for observers
        /// </summary>
        public static Logger CreateLoggerWithTracking(bool preserveLogEvents = false)
        {
            return new LoggerImpl
            {
                PreserveLogEvents = preserveLogEvents,
                InspectMessageEnabled = true,
            };
        }

        /// <summary>
        /// Logging implementation
        /// </summary>
        [System.CodeDom.Compiler.GeneratedCode("csc.exe", "4.1100.24.46003")]
        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        private class LoggerImpl : Logger
        {
            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10, () => PipProcessFileAccess_Core(context, pipSemiStableHash, pipDescription, fileAccessDescription, path));
                }
                else
                {
                    PipProcessFileAccess_Core(context, pipSemiStableHash, pipDescription, fileAccessDescription, path);
                }
            }

            private void PipProcessFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, fileAccessDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] File access on '{3}' with {2}", pipSemiStableHash, pipDescription, fileAccessDescription, path, pipSemiStableHash, pipDescription, fileAccessDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipFailSymlinkCreation(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 308, () => PipFailSymlinkCreation_Core(context, pipSemiStableHash, pipDescription, path));
                }
                else
                {
                    PipFailSymlinkCreation_Core(context, pipSemiStableHash, pipDescription, path);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(308);
                }
            }

            private void PipFailSymlinkCreation_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipFailSymlinkCreation(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(308, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process created a symlink at '{2}'. Symlink outputs are not currently supported. This error was introduced by /FailSymlinkCreationflag.", pipSemiStableHash, pipDescription, path, pipSemiStableHash, pipDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipInvalidDetoursDebugFlag1(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 23, () => PipInvalidDetoursDebugFlag1_Core(context));
                }
                else
                {
                    PipInvalidDetoursDebugFlag1_Core(context);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(23);
                }
            }

            private void PipInvalidDetoursDebugFlag1_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipInvalidDetoursDebugFlag1(context.Session.RelatedActivityId);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(23, EventLevel.Error, "A debug {ShortProductName} is using a non-debug DetoursServices.dll.", null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipInvalidDetoursDebugFlag2(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 24, () => PipInvalidDetoursDebugFlag2_Core(context));
                }
                else
                {
                    PipInvalidDetoursDebugFlag2_Core(context);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(24);
                }
            }

            private void PipInvalidDetoursDebugFlag2_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipInvalidDetoursDebugFlag2(context.Session.RelatedActivityId);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(24, EventLevel.Error, "A non-debug {ShortProductName} is using a debug DetoursServices.dll.", null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStartFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 11, () => PipProcessStartFailed_Core(context, pipSemiStableHash, pipDescription, errorCode, message));
                }
                else
                {
                    PipProcessStartFailed_Core(context, pipSemiStableHash, pipDescription, errorCode, message);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessStartFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStartFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, errorCode, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(11, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process start failed with error code {2:X8}: {3}. Pip may be retried or failed.", pipSemiStableHash, pipDescription, errorCode, message, pipSemiStableHash, pipDescription, errorCode, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFileNotFound(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string filename, string specFile, int position)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 14, () => PipProcessFileNotFound_Core(context, pipSemiStableHash, pipDescription, errorCode, filename, specFile, position));
                }
                else
                {
                    PipProcessFileNotFound_Core(context, pipSemiStableHash, pipDescription, errorCode, filename, specFile, position);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(14);
                }
            }

            private void PipProcessFileNotFound_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int errorCode, string filename, string specFile, int position)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFileNotFound(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, errorCode, filename, specFile, position);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(14, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process start failed with error code {2:X8}: File '{3}' was not found on disk. The tool is referred to in '{4}({5})'.", pipSemiStableHash, pipDescription, errorCode, filename, specFile, position, pipSemiStableHash, pipDescription, errorCode, filename, specFile, position), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinished(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12, () => PipProcessFinished_Core(context, pipSemiStableHash, pipDescription, exitCode));
                }
                else
                {
                    PipProcessFinished_Core(context, pipSemiStableHash, pipDescription, exitCode);
                }
            }

            private void PipProcessFinished_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435456))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinished(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exitCode);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process exited cleanly with exit code {2}", pipSemiStableHash, pipDescription, exitCode, pipSemiStableHash, pipDescription, exitCode), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinishedFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 13, () => PipProcessFinishedFailed_Core(context, pipSemiStableHash, pipDescription, exitCode));
                }
                else
                {
                    PipProcessFinishedFailed_Core(context, pipSemiStableHash, pipDescription, exitCode);
                }
            }

            private void PipProcessFinishedFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435456))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinishedFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exitCode);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(13, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process failed with exit code {2}", pipSemiStableHash, pipDescription, exitCode, pipSemiStableHash, pipDescription, exitCode), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessMessageParsingError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string error)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 311, () => PipProcessMessageParsingError_Core(context, pipSemiStableHash, pipDescription, error));
                }
                else
                {
                    PipProcessMessageParsingError_Core(context, pipSemiStableHash, pipDescription, error);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(311);
                }
            }

            private void PipProcessMessageParsingError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string error)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessMessageParsingError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, error);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(311, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process failed with message parsing error: {2}.", pipSemiStableHash, pipDescription, error, pipSemiStableHash, pipDescription, error), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinishedDetourFailures(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 26, () => PipProcessFinishedDetourFailures_Core(context, pipSemiStableHash, pipDescription));
                }
                else
                {
                    PipProcessFinishedDetourFailures_Core(context, pipSemiStableHash, pipDescription);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(26);
                }
            }

            private void PipProcessFinishedDetourFailures_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinishedDetourFailures(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(26, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to instrument one or more processes", pipSemiStableHash, pipDescription, pipSemiStableHash, pipDescription), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessDisallowedTempFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 20, () => PipProcessDisallowedTempFileAccess_Core(context, pipSemiStableHash, pipDescription, fileAccessDescription, path));
                }
                else
                {
                    PipProcessDisallowedTempFileAccess_Core(context, pipSemiStableHash, pipDescription, fileAccessDescription, path);
                }
            }

            private void PipProcessDisallowedTempFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessDisallowedTempFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, fileAccessDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(20, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Disallowed file access in temp directory was blocked on '{3}' with {2}; declare that this pip needs a temp directory.", pipSemiStableHash, pipDescription, fileAccessDescription, path, pipSemiStableHash, pipDescription, fileAccessDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipOutputNotAccessed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string outputFileName)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2603, () => PipOutputNotAccessed_Core(context, pipSemiStableHash, pipDescription, outputFileName));
                }
                else
                {
                    PipOutputNotAccessed_Core(context, pipSemiStableHash, pipDescription, outputFileName);
                }
            }

            private void PipOutputNotAccessed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string outputFileName)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipOutputNotAccessed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, outputFileName);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2603, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] No file access for output: {2}. Detours discovered inconsistency in detouring some child processes. Information about the inconsistency can be found in the BuildXL log file. Please, restart the build...", pipSemiStableHash, pipDescription, outputFileName, pipSemiStableHash, pipDescription, outputFileName), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessDisallowedFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 9, () => PipProcessDisallowedFileAccess_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path));
                }
                else
                {
                    PipProcessDisallowedFileAccess_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
                }
            }

            private void PipProcessDisallowedFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessDisallowedFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(9, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}] - Disallowed file access was detected on '{5}' with {4}.", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessDisallowedNtCreateFileAccessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 480, () => PipProcessDisallowedNtCreateFileAccessWarning_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path));
                }
                else
                {
                    PipProcessDisallowedNtCreateFileAccessWarning_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessDisallowedNtCreateFileAccessWarning_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessDisallowedNtCreateFileAccessWarning(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(480, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}] - Disallowed NtCreateFile access was detected on '{5}' with {4}. This warning will become an error if the '/unsafe_ignoreNtCreateFile+' is removed.", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, fileAccessDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessTookTooLongWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long softMax, long hardMax)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 15, () => PipProcessTookTooLongWarning_Core(context, pipSemiStableHash, pipDescription, actual, softMax, hardMax));
                }
                else
                {
                    PipProcessTookTooLongWarning_Core(context, pipSemiStableHash, pipDescription, actual, softMax, hardMax);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessTookTooLongWarning_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long softMax, long hardMax)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessTookTooLongWarning(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, actual, softMax, hardMax);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(15, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process ran for {2}ms, which is longer than the warning timeout of {3}ms; the process will be terminated if it ever runs longer than {4}ms", pipSemiStableHash, pipDescription, actual, softMax, hardMax, pipSemiStableHash, pipDescription, actual, softMax, hardMax), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessTookTooLongError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long time, string dumpDetails, string outputToLog)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 16, () => PipProcessTookTooLongError_Core(context, pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog));
                }
                else
                {
                    PipProcessTookTooLongError_Core(context, pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(16);
                }
            }

            private void PipProcessTookTooLongError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, long actual, long time, string dumpDetails, string outputToLog)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessTookTooLongError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(16, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process terminated because it took too long: {2}ms; the timeout is set to {3}ms. {4} \r\n Process Output: \r\n {5}", pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog, pipSemiStableHash, pipDescription, actual, time, dumpDetails, outputToLog), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStandardOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 17, () => PipProcessStandardOutput_Core(context, pipSemiStableHash, pipDescription, path));
                }
                else
                {
                    PipProcessStandardOutput_Core(context, pipSemiStableHash, pipDescription, path);
                }
            }

            private void PipProcessStandardOutput_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStandardOutput(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(17, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process standard output at '{2}'", pipSemiStableHash, pipDescription, path, pipSemiStableHash, pipDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStandardError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 18, () => PipProcessStandardError_Core(context, pipSemiStableHash, pipDescription, path));
                }
                else
                {
                    PipProcessStandardError_Core(context, pipSemiStableHash, pipDescription, path);
                }
            }

            private void PipProcessStandardError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStandardError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(18, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process standard error at '{2}'", pipSemiStableHash, pipDescription, path, pipSemiStableHash, pipDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFileAccessTableEntry(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string value)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 22, () => PipProcessFileAccessTableEntry_Core(context, pipSemiStableHash, pipDescription, value));
                }
                else
                {
                    PipProcessFileAccessTableEntry_Core(context, pipSemiStableHash, pipDescription, value);
                }
            }

            private void PipProcessFileAccessTableEntry_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string value)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFileAccessTableEntry(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, value);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(22, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] File access table entry '{2}'", pipSemiStableHash, pipDescription, value, pipSemiStableHash, pipDescription, value), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFailedToParsePathOfFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 802, () => PipProcessFailedToParsePathOfFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path));
                }
                else
                {
                    PipProcessFailedToParsePathOfFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessFailedToParsePathOfFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFailedToParsePathOfFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, operation, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(802, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Access to the following path will be ignored, since the path could not be parsed: '{3}' (Accessed via {2})", pipSemiStableHash, pipDescription, operation, path, pipSemiStableHash, pipDescription, operation, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessIgnoringPathOfSpecialDeviceFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 801, () => PipProcessIgnoringPathOfSpecialDeviceFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path));
                }
                else
                {
                    PipProcessIgnoringPathOfSpecialDeviceFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path);
                }
            }

            private void PipProcessIgnoringPathOfSpecialDeviceFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessIgnoringPathOfSpecialDeviceFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, operation, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(801, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Access to the following path will be ignored, since the path is a path to a device: '{3}' (Accessed via {2})", pipSemiStableHash, pipDescription, operation, path, pipSemiStableHash, pipDescription, operation, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessIgnoringPathWithWildcardsFileAccess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 800, () => PipProcessIgnoringPathWithWildcardsFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path));
                }
                else
                {
                    PipProcessIgnoringPathWithWildcardsFileAccess_Core(context, pipSemiStableHash, pipDescription, operation, path);
                }
            }

            private void PipProcessIgnoringPathWithWildcardsFileAccess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string operation, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessIgnoringPathWithWildcardsFileAccess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, operation, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(800, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Access to the following path will be ignored, since the path contains wildcard characters: '{3}' (Accessed via {2})", pipSemiStableHash, pipDescription, operation, path, pipSemiStableHash, pipDescription, operation, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessDisallowedFileAccessAllowlistedNonCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 269, () => PipProcessDisallowedFileAccessAllowlistedNonCacheable_Core(context, pipSemiStableHash, pipDescription, processPath, path));
                }
                else
                {
                    PipProcessDisallowedFileAccessAllowlistedNonCacheable_Core(context, pipSemiStableHash, pipDescription, processPath, path);
                }
            }

            private void PipProcessDisallowedFileAccessAllowlistedNonCacheable_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessDisallowedFileAccessAllowlistedNonCacheable(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, processPath, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(269, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.", pipSemiStableHash, pipDescription, processPath, path, pipSemiStableHash, pipDescription, processPath, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessDisallowedFileAccessAllowlistedCacheable(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 264, () => PipProcessDisallowedFileAccessAllowlistedCacheable_Core(context, pipSemiStableHash, pipDescription, processPath, path));
                }
                else
                {
                    PipProcessDisallowedFileAccessAllowlistedCacheable_Core(context, pipSemiStableHash, pipDescription, processPath, path);
                }
            }

            private void PipProcessDisallowedFileAccessAllowlistedCacheable_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessDisallowedFileAccessAllowlistedCacheable(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, processPath, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(264, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Disallowed file access (cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.", pipSemiStableHash, pipDescription, processPath, path, pipSemiStableHash, pipDescription, processPath, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FileAccessAllowlistFailedToParsePath(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string processPath, int characterWithError)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 274, () => FileAccessAllowlistFailedToParsePath_Core(context, pipSemiStableHash, pipDescription, path, processPath, characterWithError));
                }
                else
                {
                    FileAccessAllowlistFailedToParsePath_Core(context, pipSemiStableHash, pipDescription, path, processPath, characterWithError);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void FileAccessAllowlistFailedToParsePath_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string processPath, int characterWithError)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FileAccessAllowlistFailedToParsePath(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, processPath, characterWithError);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(274, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to parse tool path '{3}' at character '{4}' that accessed '{2}'. File access allowlist entries matching on tool paths will not be checked for this access.", pipSemiStableHash, pipDescription, path, processPath, characterWithError, pipSemiStableHash, pipDescription, path, processPath, characterWithError), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 4401, () => PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds_Core(context, pipSemiStableHash, pipDescription, processPath, path));
                }
                else
                {
                    PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds_Core(context, pipSemiStableHash, pipDescription, processPath, path);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(4401);
                }
            }

            private void PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string processPath, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, processPath, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(4401, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message is an error because non-cacheable allowlist matches are not allowed in distributed builds.", pipSemiStableHash, pipDescription, processPath, path, pipSemiStableHash, pipDescription, processPath, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcess(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint id, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 803, () => PipProcess_Core(context, pipSemiStableHash, pipDescription, id, path));
                }
                else
                {
                    PipProcess_Core(context, pipSemiStableHash, pipDescription, id, path);
                }
            }

            private void PipProcess_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint id, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcess(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, id, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(803, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process with id {2} at '{3}'", pipSemiStableHash, pipDescription, id, path, pipSemiStableHash, pipDescription, id, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void BrokeredDetoursInjectionFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, uint processId, string error)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10100, () => BrokeredDetoursInjectionFailed_Core(context, processId, error));
                }
                else
                {
                    BrokeredDetoursInjectionFailed_Core(context, processId, error);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(10100);
                }
            }

            private void BrokeredDetoursInjectionFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, uint processId, string error)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.BrokeredDetoursInjectionFailed(context.Session.RelatedActivityId, processId, error);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10100, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Failed to instrument process ID {0} for file monitoring on behalf of an existing instrumented process, error: {1}. Most likely reason for this error is the run time for the process exceeded the allowed timeout for the process to complete.", processId, error, processId, error), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogDetoursDebugMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10101, () => LogDetoursDebugMessage_Core(context, pipSemiStableHash, message));
                }
                else
                {
                    LogDetoursDebugMessage_Core(context, pipSemiStableHash, message);
                }
            }

            private void LogDetoursDebugMessage_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogDetoursDebugMessage(context.Session.RelatedActivityId, pipSemiStableHash, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10101, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[Pip{0:X16}] Detours Debug Message: {1}", pipSemiStableHash, message, pipSemiStableHash, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FindAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string anyBuildInstallDir)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12500, () => FindAnyBuildClient_Core(context, anyBuildInstallDir));
                }
                else
                {
                    FindAnyBuildClient_Core(context, anyBuildInstallDir);
                }
            }

            private void FindAnyBuildClient_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string anyBuildInstallDir)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FindAnyBuildClient(context.Session.RelatedActivityId, anyBuildInstallDir);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12500, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Find AnyBuild client for process remoting at '{0}'", anyBuildInstallDir, anyBuildInstallDir), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string args, string logDir)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12501, () => FindOrStartAnyBuildDaemon_Core(context, args, logDir));
                }
                else
                {
                    FindOrStartAnyBuildDaemon_Core(context, args, logDir);
                }
            }

            private void FindOrStartAnyBuildDaemon_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string args, string logDir)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FindOrStartAnyBuildDaemon(context.Session.RelatedActivityId, args, logDir);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12501, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Find or start AnyBuild daemon manager for process remoting with arguments '{0}' (log directory: '{1}')", args, logDir, args, logDir), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ExceptionOnFindOrStartAnyBuildDaemon(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12504, () => ExceptionOnFindOrStartAnyBuildDaemon_Core(context, exception));
                }
                else
                {
                    ExceptionOnFindOrStartAnyBuildDaemon_Core(context, exception);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void ExceptionOnFindOrStartAnyBuildDaemon_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ExceptionOnFindOrStartAnyBuildDaemon(context.Session.RelatedActivityId, exception);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12504, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Exception on finding or starting AnyBuild daemon: {0}", exception, exception), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ExceptionOnGetAnyBuildRemoteProcessFactory(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12505, () => ExceptionOnGetAnyBuildRemoteProcessFactory_Core(context, exception));
                }
                else
                {
                    ExceptionOnGetAnyBuildRemoteProcessFactory_Core(context, exception);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void ExceptionOnGetAnyBuildRemoteProcessFactory_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ExceptionOnGetAnyBuildRemoteProcessFactory(context.Session.RelatedActivityId, exception);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12505, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Exception on getting AnyBuild remote process factory: {0}", exception, exception), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ExceptionOnFindingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12512, () => ExceptionOnFindingAnyBuildClient_Core(context, exception));
                }
                else
                {
                    ExceptionOnFindingAnyBuildClient_Core(context, exception);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void ExceptionOnFindingAnyBuildClient_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string exception)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ExceptionOnFindingAnyBuildClient(context.Session.RelatedActivityId, exception);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12512, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Exception on finding AnyBuild client: {0}", exception, exception), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void AnyBuildRepoConfigOverrides(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string config)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12513, () => AnyBuildRepoConfigOverrides_Core(context, config));
                }
                else
                {
                    AnyBuildRepoConfigOverrides_Core(context, config);
                }
            }

            private void AnyBuildRepoConfigOverrides_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string config)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.AnyBuildRepoConfigOverrides(context.Session.RelatedActivityId, config);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12513, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "AnyBuild repo config overrides: {0}", config, config), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void InstallAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12506, () => InstallAnyBuildClient_Core(context, source, ring));
                }
                else
                {
                    InstallAnyBuildClient_Core(context, source, ring);
                }
            }

            private void InstallAnyBuildClient_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Informational, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.InstallAnyBuildClient(context.Session.RelatedActivityId, source, ring);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12506, EventLevel.Informational, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Installing AnyBuild client from '{0}' (ring: {1})", source, ring, source, ring), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void InstallAnyBuildClientDetails(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring, string reason)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12511, () => InstallAnyBuildClientDetails_Core(context, source, ring, reason));
                }
                else
                {
                    InstallAnyBuildClientDetails_Core(context, source, ring, reason);
                }
            }

            private void InstallAnyBuildClientDetails_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string source, string ring, string reason)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.InstallAnyBuildClientDetails(context.Session.RelatedActivityId, source, ring, reason);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12511, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Installing AnyBuild client from '{0}' (ring: {1}): {2}", source, ring, reason, source, ring, reason), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FailedDownloadingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12507, () => FailedDownloadingAnyBuildClient_Core(context, message));
                }
                else
                {
                    FailedDownloadingAnyBuildClient_Core(context, message);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void FailedDownloadingAnyBuildClient_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FailedDownloadingAnyBuildClient(context.Session.RelatedActivityId, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12507, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Failed downloading AnyBuild client: {0}", message, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FailedInstallingAnyBuildClient(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12508, () => FailedInstallingAnyBuildClient_Core(context, message));
                }
                else
                {
                    FailedInstallingAnyBuildClient_Core(context, message);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void FailedInstallingAnyBuildClient_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FailedInstallingAnyBuildClient(context.Session.RelatedActivityId, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12508, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Failed installing AnyBuild client: {0}", message, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void FinishedInstallAnyBuild(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12509, () => FinishedInstallAnyBuild_Core(context, message));
                }
                else
                {
                    FinishedInstallAnyBuild_Core(context, message);
                }
            }

            private void FinishedInstallAnyBuild_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FinishedInstallAnyBuild(context.Session.RelatedActivityId, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12509, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Finished installing AnyBuild client: {0}", message, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ExecuteAnyBuildBootstrapper(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string command)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12510, () => ExecuteAnyBuildBootstrapper_Core(context, command));
                }
                else
                {
                    ExecuteAnyBuildBootstrapper_Core(context, command);
                }
            }

            private void ExecuteAnyBuildBootstrapper_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string command)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ExecuteAnyBuildBootstrapper(context.Session.RelatedActivityId, command);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12510, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Execute AnyBuild bootstrapper: {0}", command, command), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogAppleSandboxPolicyGenerated(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string policyFilePath)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10102, () => LogAppleSandboxPolicyGenerated_Core(context, pipSemiStableHash, pipDescription, policyFilePath));
                }
                else
                {
                    LogAppleSandboxPolicyGenerated_Core(context, pipSemiStableHash, pipDescription, policyFilePath);
                }
            }

            private void LogAppleSandboxPolicyGenerated_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string policyFilePath)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogAppleSandboxPolicyGenerated(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, policyFilePath);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10102, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Apple sandbox-exec policy for pip generated: {2}", pipSemiStableHash, pipDescription, policyFilePath, pipSemiStableHash, pipDescription, policyFilePath), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogDetoursMaxHeapSize(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, ulong maxDetoursHeapSizeInBytes, string processName, uint processId, uint manifestSizeInBytes, ulong finalDetoursHeapSizeInBytes, uint allocatedPoolEntries, ulong maxHandleMapEntries, ulong handleMapEntries)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2928, () => LogDetoursMaxHeapSize_Core(context, pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries));
                }
                else
                {
                    LogDetoursMaxHeapSize_Core(context, pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries);
                }
            }

            private void LogDetoursMaxHeapSize_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, ulong maxDetoursHeapSizeInBytes, string processName, uint processId, uint manifestSizeInBytes, ulong finalDetoursHeapSizeInBytes, uint allocatedPoolEntries, ulong maxHandleMapEntries, ulong handleMapEntries)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435456))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogDetoursMaxHeapSize(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2928, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Maximum detours heap size for process in the pip is {2} bytes. The processName '{3}'. The processId is: {4}. The manifestSize in bytes is: {5}. The finalDetoursHeapSize in bytes is: {6}. The allocatedPoolEntries is: {7}. The maxHandleMapEntries is: {8}. The handleMapEntries is: {9}.", pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries, pipSemiStableHash, pipDescription, maxDetoursHeapSizeInBytes, processName, processId, manifestSizeInBytes, finalDetoursHeapSizeInBytes, allocatedPoolEntries, maxHandleMapEntries, handleMapEntries), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogInternalDetoursErrorFileNotEmpty(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2919, () => LogInternalDetoursErrorFileNotEmpty_Core(context, pipSemiStableHash, pipDescription, message));
                }
                else
                {
                    LogInternalDetoursErrorFileNotEmpty_Core(context, pipSemiStableHash, pipDescription, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(2919);
                }
            }

            private void LogInternalDetoursErrorFileNotEmpty_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogInternalDetoursErrorFileNotEmpty(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2919, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Detoured process emitted failure information that could not be transmitted back to BuildXL. Diagnostic file content: {2}", pipSemiStableHash, pipDescription, message, pipSemiStableHash, pipDescription, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogFailedToCreateDirectoryForInternalDetoursFailureFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2925, () => LogFailedToCreateDirectoryForInternalDetoursFailureFile_Core(context, pipSemiStableHash, pipDescription, path, message));
                }
                else
                {
                    LogFailedToCreateDirectoryForInternalDetoursFailureFile_Core(context, pipSemiStableHash, pipDescription, path, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(2925);
                }
            }

            private void LogFailedToCreateDirectoryForInternalDetoursFailureFile_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogFailedToCreateDirectoryForInternalDetoursFailureFile(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2925, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to create directory for the internal Detours error file. Path: {2}. Error: {3}", pipSemiStableHash, pipDescription, path, message, pipSemiStableHash, pipDescription, path, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogGettingInternalDetoursErrorFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2920, () => LogGettingInternalDetoursErrorFile_Core(context, pipSemiStableHash, pipDescription, message));
                }
                else
                {
                    LogGettingInternalDetoursErrorFile_Core(context, pipSemiStableHash, pipDescription, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(2920);
                }
            }

            private void LogGettingInternalDetoursErrorFile_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogGettingInternalDetoursErrorFile(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2920, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed checking for detours backup communication file existence. Pip will be treated as a failure. Error: {2}.", pipSemiStableHash, pipDescription, message, pipSemiStableHash, pipDescription, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogMismatchedDetoursCountLostMessages(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2927, () => LogMismatchedDetoursCountLostMessages_Core(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount));
                }
                else
                {
                    LogMismatchedDetoursCountLostMessages_Core(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
                }
            }

            private void LogMismatchedDetoursCountLostMessages_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogMismatchedDetoursCountLostMessages(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2927, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] The number of messages sent successfully by detoured processes did not match the number received by the bxl.exe process, which indicates lost messages. bxl.exe cannot reliably use the file accesses reported by Detours for caching the process pip. LostMessageCount: {3}", pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogMismatchedDetoursCount(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 14301, () => LogMismatchedDetoursCount_Core(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount));
                }
                else
                {
                    LogMismatchedDetoursCount_Core(context, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
                }
            }

            private void LogMismatchedDetoursCount_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogMismatchedDetoursCount(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(14301, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] The number of messages sent by detoured processes did not match the number received by the bxl.exe process, which indicates that calls to detoured APIs terminated abruptly, and indicates that the detoured processes could have a non-deterministic file access behavior. This can cause the process pip to be cached with different sets of file accesses as cache keys. DiffBetweenSendAttemptsAndReceived: {2}. LostMessageCount: {3} (<= 0 means no lost message).", pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount, pipSemiStableHash, pipDescription, lastMessageCount, lastConfirmedMessageCount), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogMessageCountSemaphoreOpenFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string failureMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2923, () => LogMessageCountSemaphoreOpenFailure_Core(context, pipSemiStableHash, pipDescription, failureMessage));
                }
                else
                {
                    LogMessageCountSemaphoreOpenFailure_Core(context, pipSemiStableHash, pipDescription, failureMessage);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(2923);
                }
            }

            private void LogMessageCountSemaphoreOpenFailure_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string failureMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogMessageCountSemaphoreOpenFailure(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, failureMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2923, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Can't open semaphore for counting Detours messages. Full failure message: {2}", pipSemiStableHash, pipDescription, failureMessage, pipSemiStableHash, pipDescription, failureMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessCommandLineTooLong(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string commandLine, int maxLength)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 32, () => PipProcessCommandLineTooLong_Core(context, pipSemiStableHash, pipDescription, commandLine, maxLength));
                }
                else
                {
                    PipProcessCommandLineTooLong_Core(context, pipSemiStableHash, pipDescription, commandLine, maxLength);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(32);
                }
            }

            private void PipProcessCommandLineTooLong_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string commandLine, int maxLength)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessCommandLineTooLong(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, commandLine, maxLength);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(32, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process command line is longer than {3} characters: {2}", pipSemiStableHash, pipDescription, commandLine, maxLength, pipSemiStableHash, pipDescription, commandLine, maxLength), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessInvalidWarningRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 39, () => PipProcessInvalidWarningRegex_Core(context, pipSemiStableHash, pipDescription, pattern, options));
                }
                else
                {
                    PipProcessInvalidWarningRegex_Core(context, pipSemiStableHash, pipDescription, pattern, options);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(39);
                }
            }

            private void PipProcessInvalidWarningRegex_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessInvalidWarningRegex(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pattern, options);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(39, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process warning regular expression is invalid, pattern is {2}, options are {3}", pipSemiStableHash, pipDescription, pattern, options, pipSemiStableHash, pipDescription, pattern, options), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessInvalidErrorRegex(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 89, () => PipProcessInvalidErrorRegex_Core(context, pipSemiStableHash, pipDescription, pattern, options));
                }
                else
                {
                    PipProcessInvalidErrorRegex_Core(context, pipSemiStableHash, pipDescription, pattern, options);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(89);
                }
            }

            private void PipProcessInvalidErrorRegex_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pattern, string options)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessInvalidErrorRegex(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pattern, options);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(89, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process error regular expression is invalid, pattern is {2}, options are {3}", pipSemiStableHash, pipDescription, pattern, options, pipSemiStableHash, pipDescription, pattern, options), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessChildrenSurvivedError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 41, () => PipProcessChildrenSurvivedError_Core(context, pipSemiStableHash, pipDescription, count, paths));
                }
                else
                {
                    PipProcessChildrenSurvivedError_Core(context, pipSemiStableHash, pipDescription, count, paths);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(41);
                }
            }

            private void PipProcessChildrenSurvivedError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessChildrenSurvivedError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, count, paths);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(41, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Unexpected child processes survived: {2} process(es){3}", pipSemiStableHash, pipDescription, count, paths, pipSemiStableHash, pipDescription, count, paths), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessChildrenSurvivedTooMany(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 43, () => PipProcessChildrenSurvivedTooMany_Core(context, pipSemiStableHash, pipDescription, count, paths));
                }
                else
                {
                    PipProcessChildrenSurvivedTooMany_Core(context, pipSemiStableHash, pipDescription, count, paths);
                }
            }

            private void PipProcessChildrenSurvivedTooMany_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int count, string paths)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessChildrenSurvivedTooMany(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, count, paths);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(43, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Too many child processes survived: {2} process(es){3}", pipSemiStableHash, pipDescription, count, paths, pipSemiStableHash, pipDescription, count, paths), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessChildrenSurvivedKilled(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 42, () => PipProcessChildrenSurvivedKilled_Core(context, pipSemiStableHash, pipDescription));
                }
                else
                {
                    PipProcessChildrenSurvivedKilled_Core(context, pipSemiStableHash, pipDescription);
                }
            }

            private void PipProcessChildrenSurvivedKilled_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessChildrenSurvivedKilled(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(42, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process and/or job containing child processes killed", pipSemiStableHash, pipDescription, pipSemiStableHash, pipDescription), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessMissingExpectedOutputOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 44, () => PipProcessMissingExpectedOutputOnCleanExit_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path));
                }
                else
                {
                    PipProcessMissingExpectedOutputOnCleanExit_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path);
                }
            }

            private void PipProcessMissingExpectedOutputOnCleanExit_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessMissingExpectedOutputOnCleanExit(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(44, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]Process was expected to write an output file at '{4}', but that file is not present.", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessWroteToStandardErrorOnCleanExit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 45, () => PipProcessWroteToStandardErrorOnCleanExit_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory));
                }
                else
                {
                    PipProcessWroteToStandardErrorOnCleanExit_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(45);
                }
            }

            private void PipProcessWroteToStandardErrorOnCleanExit_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessWroteToStandardErrorOnCleanExit(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(45, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]Process exited succesfully but wrote to standard error. The process is configured to fail in this case, even if the exit code was successful.", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessExpectedMissingOutputs(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string paths)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 504, () => PipProcessExpectedMissingOutputs_Core(context, pipSemiStableHash, pipDescription, paths));
                }
                else
                {
                    PipProcessExpectedMissingOutputs_Core(context, pipSemiStableHash, pipDescription, paths);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(504);
                }
            }

            private void PipProcessExpectedMissingOutputs_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string paths)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessExpectedMissingOutputs(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, paths);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(504, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] - Process was expected to write the following output files, but those files are not present.:\r\n{2}", pipSemiStableHash, pipDescription, paths, pipSemiStableHash, pipDescription, paths), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessOutputPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message, string exception)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 46, () => PipProcessOutputPreparationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message, exception));
                }
                else
                {
                    PipProcessOutputPreparationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message, exception);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(46);
                }
            }

            private void PipProcessOutputPreparationFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message, string exception)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)65))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessOutputPreparationFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, errorCode, message, exception);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(46, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]Process output directories could not be prepared, path '{2}', error code {3:X8}: {4}", pipSemiStableHash, pipDescription, path, errorCode, message, exception, pipSemiStableHash, pipDescription, path, errorCode, message, exception), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessOutputPreparationToBeRetriedInVM(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 47, () => PipProcessOutputPreparationToBeRetriedInVM_Core(context, pipSemiStableHash, pipDescription, path));
                }
                else
                {
                    PipProcessOutputPreparationToBeRetriedInVM_Core(context, pipSemiStableHash, pipDescription, path);
                }
            }

            private void PipProcessOutputPreparationToBeRetriedInVM_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessOutputPreparationToBeRetriedInVM(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(47, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process output '{2}' could not be prepared. Attempting to delete it from within the VM on the next retry.", pipSemiStableHash, pipDescription, path, pipSemiStableHash, pipDescription, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipStandardIOFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 316, () => PipStandardIOFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message));
                }
                else
                {
                    PipStandardIOFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(316);
                }
            }

            private void PipStandardIOFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipStandardIOFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(316, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process standard I/O failure at path '{2}', error code {3:X8}: {4}", pipSemiStableHash, pipDescription, path, errorCode, message, pipSemiStableHash, pipDescription, path, errorCode, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipExitedUncleanly(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool canceled, int errorCode, bool killed, int numSurvivingChildErrors)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 314, () => PipExitedUncleanly_Core(context, pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors));
                }
                else
                {
                    PipExitedUncleanly_Core(context, pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors);
                }
            }

            private void PipExitedUncleanly_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool canceled, int errorCode, bool killed, int numSurvivingChildErrors)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipExitedUncleanly(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(314, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Pip had unclean exit. Canceled: {2}, Error code {3}, Killed: {4}, # Surviving child errors: {5}", pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors, pipSemiStableHash, pipDescription, canceled, errorCode, killed, numSurvivingChildErrors), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipRetryDueToExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, uint processId)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 317, () => PipRetryDueToExitedWithAzureWatsonExitCode_Core(context, pipSemiStableHash, pipDescription, process, processId));
                }
                else
                {
                    PipRetryDueToExitedWithAzureWatsonExitCode_Core(context, pipSemiStableHash, pipDescription, process, processId);
                }
            }

            private void PipRetryDueToExitedWithAzureWatsonExitCode_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, uint processId)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipRetryDueToExitedWithAzureWatsonExitCode(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, process, processId);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(317, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Pip will be retried because its reported process '{2}' with pid '{3}' exited with Azure Watson's 0xDEAD exit code", pipSemiStableHash, pipDescription, process, processId, pipSemiStableHash, pipDescription, process, processId), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, string args, uint processId)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 319, () => PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode_Core(context, pipSemiStableHash, pipDescription, process, args, processId));
                }
                else
                {
                    PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode_Core(context, pipSemiStableHash, pipDescription, process, args, processId);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string process, string args, uint processId)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, process, args, processId);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(319, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Pip finished with some process (can be a child process) '{2} {3}' with pid '{4}' exited with Azure Watson's 0xDEAD exit code. Pip will not be cached if warning is treated as an error.", pipSemiStableHash, pipDescription, process, args, processId, pipSemiStableHash, pipDescription, process, args, processId), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStandardInputException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string exceptionMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 86, () => PipProcessStandardInputException_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage));
                }
                else
                {
                    PipProcessStandardInputException_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage);
                }
            }

            private void PipProcessStandardInputException_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string exceptionMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStandardInputException(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(86, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}] Unexpected standard input exception: {4}", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, exceptionMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessToolErrorDueToHandleToFileBeingUsed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string toolName, string file, string reason)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 14300, () => PipProcessToolErrorDueToHandleToFileBeingUsed_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason));
                }
                else
                {
                    PipProcessToolErrorDueToHandleToFileBeingUsed_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(14300);
                }
            }

            private void PipProcessToolErrorDueToHandleToFileBeingUsed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string toolName, string file, string reason)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessToolErrorDueToHandleToFileBeingUsed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(14300, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]The tool '{4}' cannot access the file '{5}' because it is being used by another process: \r\n{6}", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, toolName, file, reason), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog, int exitCode, string optionalMessage, string shortPipDescription, long pipExecutionTimeMs)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 64, () => PipProcessError_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs));
                }
                else
                {
                    PipProcessError_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(64);
                }
            }

            private void PipProcessError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog, int exitCode, string optionalMessage, string shortPipDescription, long pipExecutionTimeMs)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)129))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(64, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}] - failed with exit code {8}{9}\r\n{5}\r\n{6}\r\n{7}", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, exitCode, optionalMessage, shortPipDescription, pipExecutionTimeMs), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 65, () => PipProcessWarning_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog));
                }
                else
                {
                    PipProcessWarning_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessWarning_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessWarning(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(65, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}] - warnings\r\n{5}\r\n{6}\r\n{7}", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, pipExe, outputToLog, messageAboutPathsToLog, pathsToLog), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessOutput(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string outputToLog)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 66, () => PipProcessOutput_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog));
                }
                else
                {
                    PipProcessOutput_Core(context, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog);
                }
            }

            private void PipProcessOutput_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string outputToLog)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessOutput(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(66, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]\r\n{4}", pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog, pipSemiStableHash, pipDescription, pipSpecPath, pipWorkingDirectory, outputToLog), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipTempDirectoryCleanupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2201, () => PipTempDirectoryCleanupFailure_Core(context, pipSemiStableHash, pipDescription, directory, exceptionMessage));
                }
                else
                {
                    PipTempDirectoryCleanupFailure_Core(context, pipSemiStableHash, pipDescription, directory, exceptionMessage);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipTempDirectoryCleanupFailure_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)65))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipTempDirectoryCleanupFailure(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directory, exceptionMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2201, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to clean temp directory at '{2}'. Pip may be retried or failed. {3}", pipSemiStableHash, pipDescription, directory, exceptionMessage, pipSemiStableHash, pipDescription, directory, exceptionMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipTempDirectorySetupFailure(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2203, () => PipTempDirectorySetupFailure_Core(context, pipSemiStableHash, pipDescription, directory, exceptionMessage));
                }
                else
                {
                    PipTempDirectorySetupFailure_Core(context, pipSemiStableHash, pipDescription, directory, exceptionMessage);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipTempDirectorySetupFailure_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipTempDirectorySetupFailure(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directory, exceptionMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2203, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to create temp directory at '{2}'. Pip may be retried or failed. {3}", pipSemiStableHash, pipDescription, directory, exceptionMessage, pipSemiStableHash, pipDescription, directory, exceptionMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipTempSymlinkRedirectionError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory, string exceptionMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2205, () => PipTempSymlinkRedirectionError_Core(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage));
                }
                else
                {
                    PipTempSymlinkRedirectionError_Core(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(2205);
                }
            }

            private void PipTempSymlinkRedirectionError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory, string exceptionMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipTempSymlinkRedirectionError(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2205, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to create directory symlink '{2}' as a redirection for temp directory '{3}'. {4}", pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, exceptionMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipTempSymlinkRedirection(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2206, () => PipTempSymlinkRedirection_Core(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory));
                }
                else
                {
                    PipTempSymlinkRedirection_Core(context, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory);
                }
            }

            private void PipTempSymlinkRedirection_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipTempSymlinkRedirection(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2206, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Create directory symlink '{2}' as a redirection for temp directory '{3}'", pipSemiStableHash, pipDescription, directorySymlink, tempDirectory, pipSemiStableHash, pipDescription, directorySymlink, tempDirectory), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipFailedToCreateDumpFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string exceptionMessage)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 2210, () => PipFailedToCreateDumpFile_Core(context, pipSemiStableHash, pipDescription, exceptionMessage));
                }
                else
                {
                    PipFailedToCreateDumpFile_Core(context, pipSemiStableHash, pipDescription, exceptionMessage);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipFailedToCreateDumpFile_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string exceptionMessage)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipFailedToCreateDumpFile(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exceptionMessage);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(2210, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to create dump for timed out process. {2}", pipSemiStableHash, pipDescription, exceptionMessage, pipSemiStableHash, pipDescription, exceptionMessage), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void RetryStartPipDueToErrorPartialCopyDuringDetours(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int error, int retryNumber)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 85, () => RetryStartPipDueToErrorPartialCopyDuringDetours_Core(context, pipSemiStableHash, pipDescription, error, retryNumber));
                }
                else
                {
                    RetryStartPipDueToErrorPartialCopyDuringDetours_Core(context, pipSemiStableHash, pipDescription, error, retryNumber);
                }
            }

            private void RetryStartPipDueToErrorPartialCopyDuringDetours_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int error, int retryNumber)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.RetryStartPipDueToErrorPartialCopyDuringDetours(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, error, retryNumber);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(85, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]Retry to start pip for {3} time(s) due to the following error: {2}", pipSemiStableHash, pipDescription, error, retryNumber, pipSemiStableHash, pipDescription, error, retryNumber), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void DuplicateWindowsEnvironmentVariableEncountered(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string key, string existingValue, string ignoredValue)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 336, () => DuplicateWindowsEnvironmentVariableEncountered_Core(context, key, existingValue, ignoredValue));
                }
                else
                {
                    DuplicateWindowsEnvironmentVariableEncountered_Core(context, key, existingValue, ignoredValue);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void DuplicateWindowsEnvironmentVariableEncountered_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string key, string existingValue, string ignoredValue)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.DuplicateWindowsEnvironmentVariableEncountered(context.Session.RelatedActivityId, key, existingValue, ignoredValue);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(336, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Unexpected duplicate environment variable encountered. Variable '{0}' has already been defined with value '{1}'. The other occurrence with value '{2}' will be ignored.", key, existingValue, ignoredValue, key, existingValue, ignoredValue), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ReadWriteFileAccessConvertedToReadMessage(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint processId, string path)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 19, () => ReadWriteFileAccessConvertedToReadMessage_Core(context, pipSemiStableHash, pipDescription, processId, path));
                }
                else
                {
                    ReadWriteFileAccessConvertedToReadMessage_Core(context, pipSemiStableHash, pipDescription, processId, path);
                }
            }

            private void ReadWriteFileAccessConvertedToReadMessage_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, uint processId, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ReadWriteFileAccessConvertedToReadMessage(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, processId, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(19, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] File access on file '{3}' requested with Read/Write but granted for Read only by process with ID: {2}.", pipSemiStableHash, pipDescription, processId, path, pipSemiStableHash, pipDescription, processId, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ReadWriteFileAccessConvertedToReadWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 21, () => ReadWriteFileAccessConvertedToReadWarning_Core(context, pipSemiStableHash, pipDescription));
                }
                else
                {
                    ReadWriteFileAccessConvertedToReadWarning_Core(context, pipSemiStableHash, pipDescription);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void ReadWriteFileAccessConvertedToReadWarning_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ReadWriteFileAccessConvertedToReadWarning(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(21, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] This pip might have failed because of converting Read/Write file access to a Read file access. Examine the execution log for information on which files the Read/Write access request was converted to Read access request.", pipSemiStableHash, pipDescription, pipSemiStableHash, pipDescription), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessResponseFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 74, () => PipProcessResponseFileCreationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message));
                }
                else
                {
                    PipProcessResponseFileCreationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(74);
                }
            }

            private void PipProcessResponseFileCreationFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessResponseFileCreationFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(74, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}, {2}, {3}]Process response file could not be prepared, path '{2}', error code {3:X8}: {4}", pipSemiStableHash, pipDescription, path, errorCode, message, pipSemiStableHash, pipDescription, path, errorCode, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string file)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 53, () => PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate_Core(context, pipSemiStableHash, pipDescription, directory, file));
                }
                else
                {
                    PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate_Core(context, pipSemiStableHash, pipDescription, directory, file);
                }
            }

            private void PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory, string file)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directory, file);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(53, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failed to preserve output directory '{2}' because '{3}' cannot be made private, contents of the directory will be deleted", pipSemiStableHash, pipDescription, directory, file, pipSemiStableHash, pipDescription, directory, file), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 54, () => PipProcessPreserveOutputDirectorySkipMakeFilesPrivate_Core(context, pipSemiStableHash, pipDescription, directory));
                }
                else
                {
                    PipProcessPreserveOutputDirectorySkipMakeFilesPrivate_Core(context, pipSemiStableHash, pipDescription, directory);
                }
            }

            private void PipProcessPreserveOutputDirectorySkipMakeFilesPrivate_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string directory)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, directory);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(54, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Output directory '{2}' is not preserved because /unsafe_IgnorePreserveOutputsPrivatization. This can cause failure in pip execution.", pipSemiStableHash, pipDescription, directory, pipSemiStableHash, pipDescription, directory), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessChangeAffectedInputsWrittenFileCreationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 90, () => PipProcessChangeAffectedInputsWrittenFileCreationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message));
                }
                else
                {
                    PipProcessChangeAffectedInputsWrittenFileCreationFailed_Core(context, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(90);
                }
            }

            private void PipProcessChangeAffectedInputsWrittenFileCreationFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessChangeAffectedInputsWrittenFileCreationFailed(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, path, errorCode, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(90, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] File containing change affected inputs could not be prepared, path '{2}', error code {3:X8}: {4}", pipSemiStableHash, pipDescription, path, errorCode, message, pipSemiStableHash, pipDescription, path, errorCode, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void FailedToCreateHardlinkOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile, string failedStatus)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 12209, () => FailedToCreateHardlinkOnMerge_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus));
                }
                else
                {
                    FailedToCreateHardlinkOnMerge_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    loggingContext.SpecifyErrorWasLogged(12209);
                }
            }

            private void FailedToCreateHardlinkOnMerge_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile, string failedStatus)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.FailedToCreateHardlinkOnMerge(loggingContext.Session.RelatedActivityId, pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12209, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Cannot create a hardlink from '{3}' to '{2}' when merging outputs to their original location: {4}", pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus, pipSemiStableHash, pipDescription, destinationFile, sourceFile, failedStatus), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void DisallowedDoubleWriteOnMerge(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 12211, () => DisallowedDoubleWriteOnMerge_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile));
                }
                else
                {
                    DisallowedDoubleWriteOnMerge_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile, sourceFile);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    loggingContext.SpecifyErrorWasLogged(12211);
                }
            }

            private void DisallowedDoubleWriteOnMerge_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.DisallowedDoubleWriteOnMerge(loggingContext.Session.RelatedActivityId, pipSemiStableHash, pipDescription, destinationFile, sourceFile);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12211, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] A disallowed double write was detected when merging '{3}' to '{2}'.", pipSemiStableHash, pipDescription, destinationFile, sourceFile, pipSemiStableHash, pipDescription, destinationFile, sourceFile), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void DoubleWriteAllowedDueToPolicy(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 12210, () => DoubleWriteAllowedDueToPolicy_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile));
                }
                else
                {
                    DoubleWriteAllowedDueToPolicy_Core(loggingContext, pipSemiStableHash, pipDescription, destinationFile);
                }
            }

            private void DoubleWriteAllowedDueToPolicy_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, long pipSemiStableHash, string pipDescription, string destinationFile)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.DoubleWriteAllowedDueToPolicy(loggingContext.Session.RelatedActivityId, pipSemiStableHash, pipDescription, destinationFile);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12210, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Detected double write in '{2}' when merging outputs to their original location. The double write is allowed due to configured policy.", pipSemiStableHash, pipDescription, destinationFile, pipSemiStableHash, pipDescription, destinationFile), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStartExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 78, () => PipProcessStartExternalTool_Core(context, pipSemiStableHash, pipDescription, tool));
                }
                else
                {
                    PipProcessStartExternalTool_Core(context, pipSemiStableHash, pipDescription, tool);
                }
            }

            private void PipProcessStartExternalTool_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStartExternalTool(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, tool);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(78, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process execution via external tool '{2}' starts", pipSemiStableHash, pipDescription, tool, pipSemiStableHash, pipDescription, tool), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinishedExternalTool(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 79, () => PipProcessFinishedExternalTool_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr));
                }
                else
                {
                    PipProcessFinishedExternalTool_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }
            }

            private void PipProcessFinishedExternalTool_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinishedExternalTool(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(79, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process execution via external tool finished with the tool's exit code {2}:{3}{4}", pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStartRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12502, () => PipProcessStartRemoteExecution_Core(context, pipSemiStableHash, pipDescription, tool));
                }
                else
                {
                    PipProcessStartRemoteExecution_Core(context, pipSemiStableHash, pipDescription, tool);
                }
            }

            private void PipProcessStartRemoteExecution_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string tool)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStartRemoteExecution(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, tool);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12502, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Remoting process execution via '{2}' starts", pipSemiStableHash, pipDescription, tool, pipSemiStableHash, pipDescription, tool), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinishedRemoteExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12503, () => PipProcessFinishedRemoteExecution_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr));
                }
                else
                {
                    PipProcessFinishedRemoteExecution_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }
            }

            private void PipProcessFinishedRemoteExecution_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinishedRemoteExecution(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12503, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Remoting process execution via external tool finished with the tool's exit code {2}:{3}{4}", pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessStartExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 80, () => PipProcessStartExternalVm_Core(context, pipSemiStableHash, pipDescription));
                }
                else
                {
                    PipProcessStartExternalVm_Core(context, pipSemiStableHash, pipDescription);
                }
            }

            private void PipProcessStartExternalVm_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessStartExternalVm(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(80, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process execution in VM starts", pipSemiStableHash, pipDescription, pipSemiStableHash, pipDescription), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessFinishedExternalVm(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 81, () => PipProcessFinishedExternalVm_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr));
                }
                else
                {
                    PipProcessFinishedExternalVm_Core(context, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }
            }

            private void PipProcessFinishedExternalVm_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessFinishedExternalVm(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(81, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process execution in VM finished with VM's command proxy exit code {2}:{3}{4}", pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr, pipSemiStableHash, pipDescription, exitCode, stdOut, stdErr), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessExternalExecution(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 82, () => PipProcessExternalExecution_Core(context, pipSemiStableHash, pipDescription, message));
                }
                else
                {
                    PipProcessExternalExecution_Core(context, pipSemiStableHash, pipDescription, message);
                }
            }

            private void PipProcessExternalExecution_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, string message)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessExternalExecution(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, message);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(82, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] External execution: {2}", pipSemiStableHash, pipDescription, message, pipSemiStableHash, pipDescription, message), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PipProcessNeedsExecuteExternalButExecuteInternal(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool requiredAdminPrivilege, string executionMode, bool isWinOS, bool existsListener)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 92, () => PipProcessNeedsExecuteExternalButExecuteInternal_Core(context, pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener));
                }
                else
                {
                    PipProcessNeedsExecuteExternalButExecuteInternal_Core(context, pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void PipProcessNeedsExecuteExternalButExecuteInternal_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, long pipSemiStableHash, string pipDescription, bool requiredAdminPrivilege, string executionMode, bool isWinOS, bool existsListener)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PipProcessNeedsExecuteExternalButExecuteInternal(context.Session.RelatedActivityId, pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(92, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Process needs to be executed externally because (require admin privilege: {2} | execution mode: {3}), but instead it executes internally because (Win OS: {4} | listener existence: {5})", pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener, pipSemiStableHash, pipDescription, requiredAdminPrivilege, executionMode, isWinOS, existsListener), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LogPhaseDuration(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string phaseName, string duration, string extraInfo)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 93, () => LogPhaseDuration_Core(context, pipSemiStableHash, phaseName, duration, extraInfo));
                }
                else
                {
                    LogPhaseDuration_Core(context, pipSemiStableHash, phaseName, duration, extraInfo);
                }
            }

            private void LogPhaseDuration_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string phaseName, string duration, string extraInfo)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435456))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LogPhaseDuration(context.Session.RelatedActivityId, pipSemiStableHash, phaseName, duration, extraInfo);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(93, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Done with phase '{1}' in {2}.  {3}", pipSemiStableHash, phaseName, duration, extraInfo, pipSemiStableHash, phaseName, duration, extraInfo), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void CannotDeleteSharedOpaqueOutputFile(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, string failure)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 877, () => CannotDeleteSharedOpaqueOutputFile_Core(context, pipDescription, sidebandFile, files, failure));
                }
                else
                {
                    CannotDeleteSharedOpaqueOutputFile_Core(context, pipDescription, sidebandFile, files, failure);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(877);
                }
            }

            private void CannotDeleteSharedOpaqueOutputFile_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, string failure)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.CannotDeleteSharedOpaqueOutputFile(context.Session.RelatedActivityId, pipDescription, sidebandFile, files, failure);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(877, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Failed to delete shared opaque output files recorded in '{1}':{2}.  Reason: {3}", pipDescription, sidebandFile, files, failure, pipDescription, sidebandFile, files, failure), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void SharedOpaqueOutputsDeletedLazily(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, int count)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 874, () => SharedOpaqueOutputsDeletedLazily_Core(context, pipDescription, sidebandFile, files, count));
                }
                else
                {
                    SharedOpaqueOutputsDeletedLazily_Core(context, pipDescription, sidebandFile, files, count);
                }
            }

            private void SharedOpaqueOutputsDeletedLazily_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string sidebandFile, string files, int count)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.SharedOpaqueOutputsDeletedLazily(context.Session.RelatedActivityId, pipDescription, sidebandFile, files, count);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(874, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Lazily deleted {3} shared opaque output files recorded in '{1}':{2}.", pipDescription, sidebandFile, files, count, pipDescription, sidebandFile, files, count), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void CannotReadSidebandFileError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 875, () => CannotReadSidebandFileError_Core(context, fileName, error));
                }
                else
                {
                    CannotReadSidebandFileError_Core(context, fileName, error);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(875);
                }
            }

            private void CannotReadSidebandFileError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.CannotReadSidebandFileError(context.Session.RelatedActivityId, fileName, error);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(875, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Cannot read sideband file '{0}': {1}", fileName, error, fileName, error), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void CannotReadSidebandFileWarning(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 876, () => CannotReadSidebandFileWarning_Core(context, fileName, error));
                }
                else
                {
                    CannotReadSidebandFileWarning_Core(context, fileName, error);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void CannotReadSidebandFileWarning_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string fileName, string error)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.CannotReadSidebandFileWarning(context.Session.RelatedActivityId, fileName, error);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(876, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Cannot read sideband file '{0}': {1}", fileName, error, fileName, error), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ResumeOrSuspendProcessError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string failedOperation, int errorCode)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 878, () => ResumeOrSuspendProcessError_Core(context, pipSemiStableHash, failedOperation, errorCode));
                }
                else
                {
                    ResumeOrSuspendProcessError_Core(context, pipSemiStableHash, failedOperation, errorCode);
                }
            }

            private void ResumeOrSuspendProcessError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, string failedOperation, int errorCode)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ResumeOrSuspendProcessError(context.Session.RelatedActivityId, pipSemiStableHash, failedOperation, errorCode);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(878, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] occurred an error for {1}: {2}", pipSemiStableHash, failedOperation, errorCode, pipSemiStableHash, failedOperation, errorCode), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ResumeOrSuspendException(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string operation, string exception)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 879, () => ResumeOrSuspendException_Core(context, operation, exception));
                }
                else
                {
                    ResumeOrSuspendException_Core(context, operation, exception);
                }
            }

            private void ResumeOrSuspendException_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string operation, string exception)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435457))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ResumeOrSuspendException(context.Session.RelatedActivityId, operation, exception);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(879, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0} attempt failed with exception. {1}", operation, exception, operation, exception), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void CannotProbeOutputUnderSharedOpaque(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string path, string details)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 275, () => CannotProbeOutputUnderSharedOpaque_Core(context, pipDescription, path, details));
                }
                else
                {
                    CannotProbeOutputUnderSharedOpaque_Core(context, pipDescription, path, details);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(275);
                }
            }

            private void CannotProbeOutputUnderSharedOpaque_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string path, string details)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.CannotProbeOutputUnderSharedOpaque(context.Session.RelatedActivityId, pipDescription, path, details);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(275, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Failed to probe '{1}' under a shared opaque directory : {2}", pipDescription, path, details, pipDescription, path, details), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void DumpSurvivingPipProcessChildrenStatus(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string processName, string status)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12213, () => DumpSurvivingPipProcessChildrenStatus_Core(context, processName, status));
                }
                else
                {
                    DumpSurvivingPipProcessChildrenStatus_Core(context, processName, status);
                }
            }

            private void DumpSurvivingPipProcessChildrenStatus_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string processName, string status)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.DumpSurvivingPipProcessChildrenStatus(context.Session.RelatedActivityId, processName, status);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12213, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{1}] Failure during dumping unexpected surviving child processes for Process: '{0}'. Status: {1}", processName, status, processName, status), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ExistenceAssertionUnderOutputDirectoryFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string assertedOutput, string outputDirectoryRoot)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12214, () => ExistenceAssertionUnderOutputDirectoryFailed_Core(context, pipDescription, assertedOutput, outputDirectoryRoot));
                }
                else
                {
                    ExistenceAssertionUnderOutputDirectoryFailed_Core(context, pipDescription, assertedOutput, outputDirectoryRoot);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    context.SpecifyErrorWasLogged(12214);
                }
            }

            private void ExistenceAssertionUnderOutputDirectoryFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string assertedOutput, string outputDirectoryRoot)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ExistenceAssertionUnderOutputDirectoryFailed(context.Session.RelatedActivityId, pipDescription, assertedOutput, outputDirectoryRoot);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12214, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] The output file '{1}' existence was asserted under output directory root '{2}' but the file was not produced by the pip.", pipDescription, assertedOutput, outputDirectoryRoot, pipDescription, assertedOutput, outputDirectoryRoot), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void SandboxedProcessResultLogOutputTimeout(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, int timeoutInMinutes)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 12514, () => SandboxedProcessResultLogOutputTimeout_Core(context, pipSemiStableHash, timeoutInMinutes));
                }
                else
                {
                    SandboxedProcessResultLogOutputTimeout_Core(context, pipSemiStableHash, timeoutInMinutes);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void SandboxedProcessResultLogOutputTimeout_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipSemiStableHash, int timeoutInMinutes)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.SandboxedProcessResultLogOutputTimeout(context.Session.RelatedActivityId, pipSemiStableHash, timeoutInMinutes);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(12514, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Logging process StandardOutput/StandardError timed out after exceeding '{1}' minutes. This may be caused by the default terminal being Windows Terminal, workaround this by switching the default terminal to 'Windows Console Host' in Windows settings or Windows Terminal settings. Output streams may be incomplete due to this error.", pipSemiStableHash, timeoutInMinutes, pipSemiStableHash, timeoutInMinutes), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void LinuxSandboxReportedBinaryRequiringPTrace(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10104, () => LinuxSandboxReportedBinaryRequiringPTrace_Core(context, pipDescription, exePath));
                }
                else
                {
                    LinuxSandboxReportedBinaryRequiringPTrace_Core(context, pipDescription, exePath);
                }

                if (m_notifyContextWhenWarningsAreLogged)
                {
                    context.SpecifyWarningWasLogged();
                }
            }

            private void LinuxSandboxReportedBinaryRequiringPTrace_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Warning, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.LinuxSandboxReportedBinaryRequiringPTrace(context.Session.RelatedActivityId, pipDescription, exePath);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10104, EventLevel.Warning, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] The following processes '{1}' require ptrace and their file accesses may not be reported by the sandbox.", pipDescription, exePath, pipDescription, exePath), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void PTraceSandboxLaunchedForPip(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 10106, () => PTraceSandboxLaunchedForPip_Core(context, pipDescription, exePath));
                }
                else
                {
                    PTraceSandboxLaunchedForPip_Core(context, pipDescription, exePath);
                }
            }

            private void PTraceSandboxLaunchedForPip_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435457))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PTraceSandboxLaunchedForPip(context.Session.RelatedActivityId, pipDescription, exePath);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10106, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Ptrace sandbox was launched for the following processes '{1}'.", pipDescription, exePath, pipDescription, exePath), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void ProcessBreakaway(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath, uint pid)
            {
                if (context.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(context, 14303, () => ProcessBreakaway_Core(context, pipDescription, exePath, pid));
                }
                else
                {
                    ProcessBreakaway_Core(context, pipDescription, exePath, pid);
                }
            }

            private void ProcessBreakaway_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext context, string pipDescription, string exePath, uint pid)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)268435457))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ProcessBreakaway(context.Session.RelatedActivityId, pipDescription, exePath, pid);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(14303, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Process {2} with path '{1}' breaks away from the sandbox.", pipDescription, exePath, pid, pipDescription, exePath, pid), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void PTraceRunnerError(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string content)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 10105, () => PTraceRunnerError_Core(loggingContext, pipDescription, content));
                }
                else
                {
                    PTraceRunnerError_Core(loggingContext, pipDescription, content);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    loggingContext.SpecifyErrorWasLogged(10105);
                }
            }

            private void PTraceRunnerError_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string content)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.PTraceRunnerError(loggingContext.Session.RelatedActivityId, pipDescription, content);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10105, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] PTraceRunner logged the following error: {1}", pipDescription, content, pipDescription, content), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void ReportArgsMismatch(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 10107, () => ReportArgsMismatch_Core(loggingContext, pipDescription, pid));
                }
                else
                {
                    ReportArgsMismatch_Core(loggingContext, pipDescription, pid);
                }
            }

            private void ReportArgsMismatch_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ReportArgsMismatch(loggingContext.Session.RelatedActivityId, pipDescription, pid);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10107, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Received ProcessCommandLine report without a matching ProcessStart report for pid '{1}'.", pipDescription, pid, pipDescription, pid), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void ReceivedReportFromUnknownPid(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 10108, () => ReceivedReportFromUnknownPid_Core(loggingContext, pipDescription, pid));
                }
                else
                {
                    ReceivedReportFromUnknownPid_Core(loggingContext, pipDescription, pid);
                }
            }

            private void ReceivedReportFromUnknownPid_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string pipDescription, string pid)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ReceivedReportFromUnknownPid(loggingContext.Session.RelatedActivityId, pipDescription, pid);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10108, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "[{0}] Received report from unknown pid: {1}", pipDescription, pid, pipDescription, pid), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            internal override void ReceivedFileAccessReportBeforeSemaphoreInit(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string path)
            {
                if (loggingContext.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(loggingContext, 10109, () => ReceivedFileAccessReportBeforeSemaphoreInit_Core(loggingContext, path));
                }
                else
                {
                    ReceivedFileAccessReportBeforeSemaphoreInit_Core(loggingContext, path);
                }
            }

            private void ReceivedFileAccessReportBeforeSemaphoreInit_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext loggingContext, string path)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Verbose, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.ReceivedFileAccessReportBeforeSemaphoreInit(loggingContext.Session.RelatedActivityId, path);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(10109, EventLevel.Verbose, string.Format(System.Globalization.CultureInfo.InvariantCulture, "The following file access occurred before the BxlObserver was able to complete initialization '{0}'", path, path), null);
                }
            }

            /// <summary>
            /// Logging implementation
            /// </summary>
            public override void EnvironmentPreparationFailed(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext logging, string error)
            {
                if (logging.IsAsyncLoggingEnabled)
                {
                    EnqueueLogAction(logging, 14302, () => EnvironmentPreparationFailed_Core(logging, error));
                }
                else
                {
                    EnvironmentPreparationFailed_Core(logging, error);
                }

                if (m_notifyContextWhenErrorsAreLogged)
                {
                    logging.SpecifyErrorWasLogged(14302);
                }
            }

            private void EnvironmentPreparationFailed_Core(global::BuildXL.Utilities.Instrumentation.Common.LoggingContext logging, string error)
            {
                if (BuildXL.Processes.Tracing.ETWLogger.Log.IsEnabled(EventLevel.Error, (EventKeywords)1))
                {
                    BuildXL.Processes.Tracing.ETWLogger.Log.EnvironmentPreparationFailed(logging.Session.RelatedActivityId, error);
                }

                if (InspectMessageEnabled)
                {
                    InspectMessage(14302, EventLevel.Error, string.Format(System.Globalization.CultureInfo.InvariantCulture, "Could not prepare environment variables. Error: {0}", error, error), null);
                }
            }
        }

        private bool m_notifyContextWhenErrorsAreLogged = true;
        private bool m_notifyContextWhenWarningsAreLogged = true;
    }
}

namespace BuildXL.Processes.Tracing
{
    using global::System;
    using global::System.CodeDom.Compiler;
    using global::BuildXL.Utilities.Instrumentation.Common;
    using global::System.Diagnostics.Tracing;
    using global::System.Runtime.CompilerServices;

    /// <summary>
    /// Output logger that logs event into ETW
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("csc.exe", "4.1100.24.46003")]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [EventSource(Name = "BuildXL.Processes.Tracing.ETWLogger")]
    public class ETWLogger : EventSource
    {
        private static readonly ETWLogger s_log = new ETWLogger();
        /// <summary>
        /// Gets the primary event source instance.
        /// </summary>
        public static ETWLogger Log
        {
            get
            {
                return s_log;
            }
        }

        private ETWLogger() 
#if NET_FRAMEWORK_451
          : base()
#else
        : base(EventSourceSettings.EtwSelfDescribingEventFormat)
#endif
        {
        }

        /// <summary>
        /// PipProcessFileAccess
        /// </summary>
        [Event(10, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] File access on '{3}' with {2}")]
        public unsafe void PipProcessFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                fileAccessDescription = fileAccessDescription ?? String.Empty;
                fixed (char* fileAccessDescriptionBytes = fileAccessDescription)
                {
                    data[2].DataPointer = (IntPtr)fileAccessDescriptionBytes;
                    data[2].Size = ((fileAccessDescription.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(10, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipFailSymlinkCreation
        /// </summary>
        [Event(308, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process created a symlink at '{2}'. Symlink outputs are not currently supported. This error was introduced by /FailSymlinkCreationflag.")]
        public unsafe void PipFailSymlinkCreation(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(308, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipInvalidDetoursDebugFlag1
        /// </summary>
        [Event(23, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "A debug BuildXL is using a non-debug DetoursServices.dll.")]
        public unsafe void PipInvalidDetoursDebugFlag1(Guid relatedActivityId)
        {
            WriteEventWithRelatedActivityIdCore(23, &relatedActivityId, 0, null);
        }

        /// <summary>
        /// PipInvalidDetoursDebugFlag2
        /// </summary>
        [Event(24, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "A non-debug BuildXL is using a debug DetoursServices.dll.")]
        public unsafe void PipInvalidDetoursDebugFlag2(Guid relatedActivityId)
        {
            WriteEventWithRelatedActivityIdCore(24, &relatedActivityId, 0, null);
        }

        /// <summary>
        /// PipProcessStartFailed
        /// </summary>
        [Event(11, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process start failed with error code {2:X8}: {3}. Pip may be retried or failed.")]
        public unsafe void PipProcessStartFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int errorCode, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&errorCode);
                data[2].Size = sizeof(int);
                message = message ?? String.Empty;
                fixed (char* messageBytes = message)
                {
                    data[3].DataPointer = (IntPtr)messageBytes;
                    data[3].Size = ((message.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(11, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFileNotFound
        /// </summary>
        [Event(14, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process start failed with error code {2:X8}: File '{3}' was not found on disk. The tool is referred to in '{4}({5})'.")]
        public unsafe void PipProcessFileNotFound(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int errorCode, string filename, string specFile, int position)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&errorCode);
                data[2].Size = sizeof(int);
                filename = filename ?? String.Empty;
                fixed (char* filenameBytes = filename)
                {
                    data[3].DataPointer = (IntPtr)filenameBytes;
                    data[3].Size = ((filename.Length + 1) * 2);
                    specFile = specFile ?? String.Empty;
                    fixed (char* specFileBytes = specFile)
                    {
                        data[4].DataPointer = (IntPtr)specFileBytes;
                        data[4].Size = ((specFile.Length + 1) * 2);
                        data[5].DataPointer = (IntPtr)(&position);
                        data[5].Size = sizeof(int);
                        WriteEventWithRelatedActivityIdCore(14, &relatedActivityId, 6, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessFinished
        /// </summary>
        [Event(12, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435456, Task = (EventTask)9, Message = "[{1}] Process exited cleanly with exit code {2}")]
        public unsafe void PipProcessFinished(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int exitCode)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&exitCode);
                data[2].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(12, &relatedActivityId, 3, data);
            }
        }

        /// <summary>
        /// PipProcessFinishedFailed
        /// </summary>
        [Event(13, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435456, Task = (EventTask)9, Message = "[{1}] Process failed with exit code {2}")]
        public unsafe void PipProcessFinishedFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int exitCode)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&exitCode);
                data[2].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(13, &relatedActivityId, 3, data);
            }
        }

        /// <summary>
        /// PipProcessMessageParsingError
        /// </summary>
        [Event(311, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process failed with message parsing error: {2}.")]
        public unsafe void PipProcessMessageParsingError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string error)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                error = error ?? String.Empty;
                fixed (char* errorBytes = error)
                {
                    data[2].DataPointer = (IntPtr)errorBytes;
                    data[2].Size = ((error.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(311, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFinishedDetourFailures
        /// </summary>
        [Event(26, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to instrument one or more processes")]
        public unsafe void PipProcessFinishedDetourFailures(Guid relatedActivityId, long pipSemiStableHash, string pipDescription)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(26, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// PipProcessDisallowedTempFileAccess
        /// </summary>
        [Event(20, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Disallowed file access in temp directory was blocked on '{3}' with {2}; declare that this pip needs a temp directory.")]
        public unsafe void PipProcessDisallowedTempFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string fileAccessDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                fileAccessDescription = fileAccessDescription ?? String.Empty;
                fixed (char* fileAccessDescriptionBytes = fileAccessDescription)
                {
                    data[2].DataPointer = (IntPtr)fileAccessDescriptionBytes;
                    data[2].Size = ((fileAccessDescription.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(20, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipOutputNotAccessed
        /// </summary>
        [Event(2603, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] No file access for output: {2}. Detours discovered inconsistency in detouring some child processes. Information about the inconsistency can be found in the BuildXL log file. Please, restart the build...")]
        public unsafe void PipOutputNotAccessed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string outputFileName)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                outputFileName = outputFileName ?? String.Empty;
                fixed (char* outputFileNameBytes = outputFileName)
                {
                    data[2].DataPointer = (IntPtr)outputFileNameBytes;
                    data[2].Size = ((outputFileName.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(2603, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessDisallowedFileAccess
        /// </summary>
        [Event(9, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}] - Disallowed file access was detected on '{5}' with {4}.")]
        public unsafe void PipProcessDisallowedFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        fileAccessDescription = fileAccessDescription ?? String.Empty;
                        fixed (char* fileAccessDescriptionBytes = fileAccessDescription)
                        {
                            data[4].DataPointer = (IntPtr)fileAccessDescriptionBytes;
                            data[4].Size = ((fileAccessDescription.Length + 1) * 2);
                            path = path ?? String.Empty;
                            fixed (char* pathBytes = path)
                            {
                                data[5].DataPointer = (IntPtr)pathBytes;
                                data[5].Size = ((path.Length + 1) * 2);
                                WriteEventWithRelatedActivityIdCore(9, &relatedActivityId, 6, data);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessDisallowedNtCreateFileAccessWarning
        /// </summary>
        [Event(480, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}] - Disallowed NtCreateFile access was detected on '{5}' with {4}. This warning will become an error if the '/unsafe_ignoreNtCreateFile+' is removed.")]
        public unsafe void PipProcessDisallowedNtCreateFileAccessWarning(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string fileAccessDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        fileAccessDescription = fileAccessDescription ?? String.Empty;
                        fixed (char* fileAccessDescriptionBytes = fileAccessDescription)
                        {
                            data[4].DataPointer = (IntPtr)fileAccessDescriptionBytes;
                            data[4].Size = ((fileAccessDescription.Length + 1) * 2);
                            path = path ?? String.Empty;
                            fixed (char* pathBytes = path)
                            {
                                data[5].DataPointer = (IntPtr)pathBytes;
                                data[5].Size = ((path.Length + 1) * 2);
                                WriteEventWithRelatedActivityIdCore(480, &relatedActivityId, 6, data);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessTookTooLongWarning
        /// </summary>
        [Event(15, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process ran for {2}ms, which is longer than the warning timeout of {3}ms; the process will be terminated if it ever runs longer than {4}ms")]
        public unsafe void PipProcessTookTooLongWarning(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, long actual, long softMax, long hardMax)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&actual);
                data[2].Size = sizeof(long);
                data[3].DataPointer = (IntPtr)(&softMax);
                data[3].Size = sizeof(long);
                data[4].DataPointer = (IntPtr)(&hardMax);
                data[4].Size = sizeof(long);
                WriteEventWithRelatedActivityIdCore(15, &relatedActivityId, 5, data);
            }
        }

        /// <summary>
        /// PipProcessTookTooLongError
        /// </summary>
        [Event(16, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process terminated because it took too long: {2}ms; the timeout is set to {3}ms. {4} \r\n Process Output: \r\n {5}")]
        public unsafe void PipProcessTookTooLongError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, long actual, long time, string dumpDetails, string outputToLog)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&actual);
                data[2].Size = sizeof(long);
                data[3].DataPointer = (IntPtr)(&time);
                data[3].Size = sizeof(long);
                dumpDetails = dumpDetails ?? String.Empty;
                fixed (char* dumpDetailsBytes = dumpDetails)
                {
                    data[4].DataPointer = (IntPtr)dumpDetailsBytes;
                    data[4].Size = ((dumpDetails.Length + 1) * 2);
                    outputToLog = outputToLog ?? String.Empty;
                    fixed (char* outputToLogBytes = outputToLog)
                    {
                        data[5].DataPointer = (IntPtr)outputToLogBytes;
                        data[5].Size = ((outputToLog.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(16, &relatedActivityId, 6, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessStandardOutput
        /// </summary>
        [Event(17, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process standard output at '{2}'")]
        public unsafe void PipProcessStandardOutput(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(17, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessStandardError
        /// </summary>
        [Event(18, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process standard error at '{2}'")]
        public unsafe void PipProcessStandardError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(18, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFileAccessTableEntry
        /// </summary>
        [Event(22, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] File access table entry '{2}'")]
        public unsafe void PipProcessFileAccessTableEntry(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string value)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                value = value ?? String.Empty;
                fixed (char* valueBytes = value)
                {
                    data[2].DataPointer = (IntPtr)valueBytes;
                    data[2].Size = ((value.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(22, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFailedToParsePathOfFileAccess
        /// </summary>
        [Event(802, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Access to the following path will be ignored, since the path could not be parsed: '{3}' (Accessed via {2})")]
        public unsafe void PipProcessFailedToParsePathOfFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                operation = operation ?? String.Empty;
                fixed (char* operationBytes = operation)
                {
                    data[2].DataPointer = (IntPtr)operationBytes;
                    data[2].Size = ((operation.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(802, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessIgnoringPathOfSpecialDeviceFileAccess
        /// </summary>
        [Event(801, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Access to the following path will be ignored, since the path is a path to a device: '{3}' (Accessed via {2})")]
        public unsafe void PipProcessIgnoringPathOfSpecialDeviceFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                operation = operation ?? String.Empty;
                fixed (char* operationBytes = operation)
                {
                    data[2].DataPointer = (IntPtr)operationBytes;
                    data[2].Size = ((operation.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(801, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessIgnoringPathWithWildcardsFileAccess
        /// </summary>
        [Event(800, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Access to the following path will be ignored, since the path contains wildcard characters: '{3}' (Accessed via {2})")]
        public unsafe void PipProcessIgnoringPathWithWildcardsFileAccess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string operation, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                operation = operation ?? String.Empty;
                fixed (char* operationBytes = operation)
                {
                    data[2].DataPointer = (IntPtr)operationBytes;
                    data[2].Size = ((operation.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(800, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessDisallowedFileAccessAllowlistedNonCacheable
        /// </summary>
        [Event(269, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.")]
        public unsafe void PipProcessDisallowedFileAccessAllowlistedNonCacheable(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                processPath = processPath ?? String.Empty;
                fixed (char* processPathBytes = processPath)
                {
                    data[2].DataPointer = (IntPtr)processPathBytes;
                    data[2].Size = ((processPath.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(269, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessDisallowedFileAccessAllowlistedCacheable
        /// </summary>
        [Event(264, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Disallowed file access (cacheable) was detected on '{3}' with {2}. This message will become an error if the allowlist entry (in a top-level configuration file) allowing this access is removed.")]
        public unsafe void PipProcessDisallowedFileAccessAllowlistedCacheable(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                processPath = processPath ?? String.Empty;
                fixed (char* processPathBytes = processPath)
                {
                    data[2].DataPointer = (IntPtr)processPathBytes;
                    data[2].Size = ((processPath.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(264, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// FileAccessAllowlistFailedToParsePath
        /// </summary>
        [Event(274, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to parse tool path '{3}' at character '{4}' that accessed '{2}'. File access allowlist entries matching on tool paths will not be checked for this access.")]
        public unsafe void FileAccessAllowlistFailedToParsePath(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, string processPath, int characterWithError)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    processPath = processPath ?? String.Empty;
                    fixed (char* processPathBytes = processPath)
                    {
                        data[3].DataPointer = (IntPtr)processPathBytes;
                        data[3].Size = ((processPath.Length + 1) * 2);
                        data[4].DataPointer = (IntPtr)(&characterWithError);
                        data[4].Size = sizeof(int);
                        WriteEventWithRelatedActivityIdCore(274, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds
        /// </summary>
        [Event(4401, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Disallowed file access (non-cacheable) was detected on '{3}' with {2}. This message is an error because non-cacheable allowlist matches are not allowed in distributed builds.")]
        public unsafe void PipProcessUncacheableAllowlistNotAllowedInDistributedBuilds(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string processPath, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                processPath = processPath ?? String.Empty;
                fixed (char* processPathBytes = processPath)
                {
                    data[2].DataPointer = (IntPtr)processPathBytes;
                    data[2].Size = ((processPath.Length + 1) * 2);
                    path = path ?? String.Empty;
                    fixed (char* pathBytes = path)
                    {
                        data[3].DataPointer = (IntPtr)pathBytes;
                        data[3].Size = ((path.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(4401, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcess
        /// </summary>
        [Event(803, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process with id {2} at '{3}'")]
        public unsafe void PipProcess(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, uint id, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&id);
                data[2].Size = sizeof(uint);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[3].DataPointer = (IntPtr)pathBytes;
                    data[3].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(803, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// BrokeredDetoursInjectionFailed
        /// </summary>
        [Event(10100, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Failed to instrument process ID {0} for file monitoring on behalf of an existing instrumented process, error: {1}. Most likely reason for this error is the run time for the process exceeded the allowed timeout for the process to complete.")]
        public unsafe void BrokeredDetoursInjectionFailed(Guid relatedActivityId, uint processId, string error)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&processId);
            data[0].Size = sizeof(uint);
            error = error ?? String.Empty;
            fixed (char* errorBytes = error)
            {
                data[1].DataPointer = (IntPtr)errorBytes;
                data[1].Size = ((error.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(10100, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// LogDetoursDebugMessage
        /// </summary>
        [Event(10101, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[Pip{0:X16}] Detours Debug Message: {1}")]
        public unsafe void LogDetoursDebugMessage(Guid relatedActivityId, long pipSemiStableHash, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            message = message ?? String.Empty;
            fixed (char* messageBytes = message)
            {
                data[1].DataPointer = (IntPtr)messageBytes;
                data[1].Size = ((message.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(10101, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// FindAnyBuildClient
        /// </summary>
        [Event(12500, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Find AnyBuild client for process remoting at '{0}'")]
        public unsafe void FindAnyBuildClient(Guid relatedActivityId, string anyBuildInstallDir)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            anyBuildInstallDir = anyBuildInstallDir ?? String.Empty;
            fixed (char* anyBuildInstallDirBytes = anyBuildInstallDir)
            {
                data[0].DataPointer = (IntPtr)anyBuildInstallDirBytes;
                data[0].Size = ((anyBuildInstallDir.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12500, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// FindOrStartAnyBuildDaemon
        /// </summary>
        [Event(12501, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Find or start AnyBuild daemon manager for process remoting with arguments '{0}' (log directory: '{1}')")]
        public unsafe void FindOrStartAnyBuildDaemon(Guid relatedActivityId, string args, string logDir)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            args = args ?? String.Empty;
            fixed (char* argsBytes = args)
            {
                data[0].DataPointer = (IntPtr)argsBytes;
                data[0].Size = ((args.Length + 1) * 2);
                logDir = logDir ?? String.Empty;
                fixed (char* logDirBytes = logDir)
                {
                    data[1].DataPointer = (IntPtr)logDirBytes;
                    data[1].Size = ((logDir.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(12501, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ExceptionOnFindOrStartAnyBuildDaemon
        /// </summary>
        [Event(12504, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Exception on finding or starting AnyBuild daemon: {0}")]
        public unsafe void ExceptionOnFindOrStartAnyBuildDaemon(Guid relatedActivityId, string exception)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            exception = exception ?? String.Empty;
            fixed (char* exceptionBytes = exception)
            {
                data[0].DataPointer = (IntPtr)exceptionBytes;
                data[0].Size = ((exception.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12504, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// ExceptionOnGetAnyBuildRemoteProcessFactory
        /// </summary>
        [Event(12505, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Exception on getting AnyBuild remote process factory: {0}")]
        public unsafe void ExceptionOnGetAnyBuildRemoteProcessFactory(Guid relatedActivityId, string exception)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            exception = exception ?? String.Empty;
            fixed (char* exceptionBytes = exception)
            {
                data[0].DataPointer = (IntPtr)exceptionBytes;
                data[0].Size = ((exception.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12505, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// ExceptionOnFindingAnyBuildClient
        /// </summary>
        [Event(12512, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Exception on finding AnyBuild client: {0}")]
        public unsafe void ExceptionOnFindingAnyBuildClient(Guid relatedActivityId, string exception)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            exception = exception ?? String.Empty;
            fixed (char* exceptionBytes = exception)
            {
                data[0].DataPointer = (IntPtr)exceptionBytes;
                data[0].Size = ((exception.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12512, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// AnyBuildRepoConfigOverrides
        /// </summary>
        [Event(12513, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "AnyBuild repo config overrides: {0}")]
        public unsafe void AnyBuildRepoConfigOverrides(Guid relatedActivityId, string config)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            config = config ?? String.Empty;
            fixed (char* configBytes = config)
            {
                data[0].DataPointer = (IntPtr)configBytes;
                data[0].Size = ((config.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12513, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// InstallAnyBuildClient
        /// </summary>
        [Event(12506, Level = EventLevel.Informational, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Installing AnyBuild client from '{0}' (ring: {1})")]
        public unsafe void InstallAnyBuildClient(Guid relatedActivityId, string source, string ring)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            source = source ?? String.Empty;
            fixed (char* sourceBytes = source)
            {
                data[0].DataPointer = (IntPtr)sourceBytes;
                data[0].Size = ((source.Length + 1) * 2);
                ring = ring ?? String.Empty;
                fixed (char* ringBytes = ring)
                {
                    data[1].DataPointer = (IntPtr)ringBytes;
                    data[1].Size = ((ring.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(12506, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// InstallAnyBuildClientDetails
        /// </summary>
        [Event(12511, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Installing AnyBuild client from '{0}' (ring: {1}): {2}")]
        public unsafe void InstallAnyBuildClientDetails(Guid relatedActivityId, string source, string ring, string reason)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            source = source ?? String.Empty;
            fixed (char* sourceBytes = source)
            {
                data[0].DataPointer = (IntPtr)sourceBytes;
                data[0].Size = ((source.Length + 1) * 2);
                ring = ring ?? String.Empty;
                fixed (char* ringBytes = ring)
                {
                    data[1].DataPointer = (IntPtr)ringBytes;
                    data[1].Size = ((ring.Length + 1) * 2);
                    reason = reason ?? String.Empty;
                    fixed (char* reasonBytes = reason)
                    {
                        data[2].DataPointer = (IntPtr)reasonBytes;
                        data[2].Size = ((reason.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(12511, &relatedActivityId, 3, data);
                    }
                }
            }
        }

        /// <summary>
        /// FailedDownloadingAnyBuildClient
        /// </summary>
        [Event(12507, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Failed downloading AnyBuild client: {0}")]
        public unsafe void FailedDownloadingAnyBuildClient(Guid relatedActivityId, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            message = message ?? String.Empty;
            fixed (char* messageBytes = message)
            {
                data[0].DataPointer = (IntPtr)messageBytes;
                data[0].Size = ((message.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12507, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// FailedInstallingAnyBuildClient
        /// </summary>
        [Event(12508, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Failed installing AnyBuild client: {0}")]
        public unsafe void FailedInstallingAnyBuildClient(Guid relatedActivityId, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            message = message ?? String.Empty;
            fixed (char* messageBytes = message)
            {
                data[0].DataPointer = (IntPtr)messageBytes;
                data[0].Size = ((message.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12508, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// FinishedInstallAnyBuild
        /// </summary>
        [Event(12509, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Finished installing AnyBuild client: {0}")]
        public unsafe void FinishedInstallAnyBuild(Guid relatedActivityId, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            message = message ?? String.Empty;
            fixed (char* messageBytes = message)
            {
                data[0].DataPointer = (IntPtr)messageBytes;
                data[0].Size = ((message.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12509, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// ExecuteAnyBuildBootstrapper
        /// </summary>
        [Event(12510, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "Execute AnyBuild bootstrapper: {0}")]
        public unsafe void ExecuteAnyBuildBootstrapper(Guid relatedActivityId, string command)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            command = command ?? String.Empty;
            fixed (char* commandBytes = command)
            {
                data[0].DataPointer = (IntPtr)commandBytes;
                data[0].Size = ((command.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(12510, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// LogAppleSandboxPolicyGenerated
        /// </summary>
        [Event(10102, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Apple sandbox-exec policy for pip generated: {2}")]
        public unsafe void LogAppleSandboxPolicyGenerated(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string policyFilePath)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                policyFilePath = policyFilePath ?? String.Empty;
                fixed (char* policyFilePathBytes = policyFilePath)
                {
                    data[2].DataPointer = (IntPtr)policyFilePathBytes;
                    data[2].Size = ((policyFilePath.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10102, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// LogDetoursMaxHeapSize
        /// </summary>
        [Event(2928, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435456, Task = (EventTask)9, Message = "[{1}] Maximum detours heap size for process in the pip is {2} bytes. The processName '{3}'. The processId is: {4}. The manifestSize in bytes is: {5}. The finalDetoursHeapSize in bytes is: {6}. The allocatedPoolEntries is: {7}. The maxHandleMapEntries is: {8}. The handleMapEntries is: {9}.")]
        public unsafe void LogDetoursMaxHeapSize(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, ulong maxDetoursHeapSizeInBytes, string processName, uint processId, uint manifestSizeInBytes, ulong finalDetoursHeapSizeInBytes, uint allocatedPoolEntries, ulong maxHandleMapEntries, ulong handleMapEntries)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[10];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&maxDetoursHeapSizeInBytes);
                data[2].Size = sizeof(ulong);
                processName = processName ?? String.Empty;
                fixed (char* processNameBytes = processName)
                {
                    data[3].DataPointer = (IntPtr)processNameBytes;
                    data[3].Size = ((processName.Length + 1) * 2);
                    data[4].DataPointer = (IntPtr)(&processId);
                    data[4].Size = sizeof(uint);
                    data[5].DataPointer = (IntPtr)(&manifestSizeInBytes);
                    data[5].Size = sizeof(uint);
                    data[6].DataPointer = (IntPtr)(&finalDetoursHeapSizeInBytes);
                    data[6].Size = sizeof(ulong);
                    data[7].DataPointer = (IntPtr)(&allocatedPoolEntries);
                    data[7].Size = sizeof(uint);
                    data[8].DataPointer = (IntPtr)(&maxHandleMapEntries);
                    data[8].Size = sizeof(ulong);
                    data[9].DataPointer = (IntPtr)(&handleMapEntries);
                    data[9].Size = sizeof(ulong);
                    WriteEventWithRelatedActivityIdCore(2928, &relatedActivityId, 10, data);
                }
            }
        }

        /// <summary>
        /// LogInternalDetoursErrorFileNotEmpty
        /// </summary>
        [Event(2919, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Detoured process emitted failure information that could not be transmitted back to BuildXL. Diagnostic file content: {2}")]
        public unsafe void LogInternalDetoursErrorFileNotEmpty(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                message = message ?? String.Empty;
                fixed (char* messageBytes = message)
                {
                    data[2].DataPointer = (IntPtr)messageBytes;
                    data[2].Size = ((message.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(2919, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// LogFailedToCreateDirectoryForInternalDetoursFailureFile
        /// </summary>
        [Event(2925, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to create directory for the internal Detours error file. Path: {2}. Error: {3}")]
        public unsafe void LogFailedToCreateDirectoryForInternalDetoursFailureFile(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    message = message ?? String.Empty;
                    fixed (char* messageBytes = message)
                    {
                        data[3].DataPointer = (IntPtr)messageBytes;
                        data[3].Size = ((message.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(2925, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// LogGettingInternalDetoursErrorFile
        /// </summary>
        [Event(2920, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed checking for detours backup communication file existence. Pip will be treated as a failure. Error: {2}.")]
        public unsafe void LogGettingInternalDetoursErrorFile(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                message = message ?? String.Empty;
                fixed (char* messageBytes = message)
                {
                    data[2].DataPointer = (IntPtr)messageBytes;
                    data[2].Size = ((message.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(2920, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// LogMismatchedDetoursCountLostMessages
        /// </summary>
        [Event(2927, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] The number of messages sent successfully by detoured processes did not match the number received by the bxl.exe process, which indicates lost messages. bxl.exe cannot reliably use the file accesses reported by Detours for caching the process pip. LostMessageCount: {3}")]
        public unsafe void LogMismatchedDetoursCountLostMessages(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&lastMessageCount);
                data[2].Size = sizeof(int);
                data[3].DataPointer = (IntPtr)(&lastConfirmedMessageCount);
                data[3].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(2927, &relatedActivityId, 4, data);
            }
        }

        /// <summary>
        /// LogMismatchedDetoursCount
        /// </summary>
        [Event(14301, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] The number of messages sent by detoured processes did not match the number received by the bxl.exe process, which indicates that calls to detoured APIs terminated abruptly, and indicates that the detoured processes could have a non-deterministic file access behavior. This can cause the process pip to be cached with different sets of file accesses as cache keys. DiffBetweenSendAttemptsAndReceived: {2}. LostMessageCount: {3} (<= 0 means no lost message).")]
        public unsafe void LogMismatchedDetoursCount(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int lastMessageCount, int lastConfirmedMessageCount)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&lastMessageCount);
                data[2].Size = sizeof(int);
                data[3].DataPointer = (IntPtr)(&lastConfirmedMessageCount);
                data[3].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(14301, &relatedActivityId, 4, data);
            }
        }

        /// <summary>
        /// LogMessageCountSemaphoreOpenFailure
        /// </summary>
        [Event(2923, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Can't open semaphore for counting Detours messages. Full failure message: {2}")]
        public unsafe void LogMessageCountSemaphoreOpenFailure(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string failureMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                failureMessage = failureMessage ?? String.Empty;
                fixed (char* failureMessageBytes = failureMessage)
                {
                    data[2].DataPointer = (IntPtr)failureMessageBytes;
                    data[2].Size = ((failureMessage.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(2923, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessCommandLineTooLong
        /// </summary>
        [Event(32, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process command line is longer than {3} characters: {2}")]
        public unsafe void PipProcessCommandLineTooLong(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string commandLine, int maxLength)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                commandLine = commandLine ?? String.Empty;
                fixed (char* commandLineBytes = commandLine)
                {
                    data[2].DataPointer = (IntPtr)commandLineBytes;
                    data[2].Size = ((commandLine.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&maxLength);
                    data[3].Size = sizeof(int);
                    WriteEventWithRelatedActivityIdCore(32, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// PipProcessInvalidWarningRegex
        /// </summary>
        [Event(39, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process warning regular expression is invalid, pattern is {2}, options are {3}")]
        public unsafe void PipProcessInvalidWarningRegex(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pattern, string options)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pattern = pattern ?? String.Empty;
                fixed (char* patternBytes = pattern)
                {
                    data[2].DataPointer = (IntPtr)patternBytes;
                    data[2].Size = ((pattern.Length + 1) * 2);
                    options = options ?? String.Empty;
                    fixed (char* optionsBytes = options)
                    {
                        data[3].DataPointer = (IntPtr)optionsBytes;
                        data[3].Size = ((options.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(39, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessInvalidErrorRegex
        /// </summary>
        [Event(89, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Process error regular expression is invalid, pattern is {2}, options are {3}")]
        public unsafe void PipProcessInvalidErrorRegex(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pattern, string options)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pattern = pattern ?? String.Empty;
                fixed (char* patternBytes = pattern)
                {
                    data[2].DataPointer = (IntPtr)patternBytes;
                    data[2].Size = ((pattern.Length + 1) * 2);
                    options = options ?? String.Empty;
                    fixed (char* optionsBytes = options)
                    {
                        data[3].DataPointer = (IntPtr)optionsBytes;
                        data[3].Size = ((options.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(89, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessChildrenSurvivedError
        /// </summary>
        [Event(41, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] Unexpected child processes survived: {2} process(es){3}")]
        public unsafe void PipProcessChildrenSurvivedError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int count, string paths)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&count);
                data[2].Size = sizeof(int);
                paths = paths ?? String.Empty;
                fixed (char* pathsBytes = paths)
                {
                    data[3].DataPointer = (IntPtr)pathsBytes;
                    data[3].Size = ((paths.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(41, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// PipProcessChildrenSurvivedTooMany
        /// </summary>
        [Event(43, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Too many child processes survived: {2} process(es){3}")]
        public unsafe void PipProcessChildrenSurvivedTooMany(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int count, string paths)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&count);
                data[2].Size = sizeof(int);
                paths = paths ?? String.Empty;
                fixed (char* pathsBytes = paths)
                {
                    data[3].DataPointer = (IntPtr)pathsBytes;
                    data[3].Size = ((paths.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(43, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// PipProcessChildrenSurvivedKilled
        /// </summary>
        [Event(42, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process and/or job containing child processes killed")]
        public unsafe void PipProcessChildrenSurvivedKilled(Guid relatedActivityId, long pipSemiStableHash, string pipDescription)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(42, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// PipProcessMissingExpectedOutputOnCleanExit
        /// </summary>
        [Event(44, Level = EventLevel.Verbose, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}, {2}, {3}]Process was expected to write an output file at '{4}', but that file is not present.")]
        public unsafe void PipProcessMissingExpectedOutputOnCleanExit(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        path = path ?? String.Empty;
                        fixed (char* pathBytes = path)
                        {
                            data[4].DataPointer = (IntPtr)pathBytes;
                            data[4].Size = ((path.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(44, &relatedActivityId, 5, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessWroteToStandardErrorOnCleanExit
        /// </summary>
        [Event(45, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}, {2}, {3}]Process exited succesfully but wrote to standard error. The process is configured to fail in this case, even if the exit code was successful.")]
        public unsafe void PipProcessWroteToStandardErrorOnCleanExit(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(45, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessExpectedMissingOutputs
        /// </summary>
        [Event(504, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}] - Process was expected to write the following output files, but those files are not present.:\r\n{2}")]
        public unsafe void PipProcessExpectedMissingOutputs(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string paths)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                paths = paths ?? String.Empty;
                fixed (char* pathsBytes = paths)
                {
                    data[2].DataPointer = (IntPtr)pathsBytes;
                    data[2].Size = ((paths.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(504, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessOutputPreparationFailed
        /// </summary>
        [Event(46, Level = EventLevel.Error, Keywords = (EventKeywords)65, Task = (EventTask)9, Message = "[{1}, {2}, {3}]Process output directories could not be prepared, path '{2}', error code {3:X8}: {4}")]
        public unsafe void PipProcessOutputPreparationFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message, string exception)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&errorCode);
                    data[3].Size = sizeof(int);
                    message = message ?? String.Empty;
                    fixed (char* messageBytes = message)
                    {
                        data[4].DataPointer = (IntPtr)messageBytes;
                        data[4].Size = ((message.Length + 1) * 2);
                        exception = exception ?? String.Empty;
                        fixed (char* exceptionBytes = exception)
                        {
                            data[5].DataPointer = (IntPtr)exceptionBytes;
                            data[5].Size = ((exception.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(46, &relatedActivityId, 6, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessOutputPreparationToBeRetriedInVM
        /// </summary>
        [Event(47, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process output '{2}' could not be prepared. Attempting to delete it from within the VM on the next retry.")]
        public unsafe void PipProcessOutputPreparationToBeRetriedInVM(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(47, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipStandardIOFailed
        /// </summary>
        [Event(316, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process standard I/O failure at path '{2}', error code {3:X8}: {4}")]
        public unsafe void PipStandardIOFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&errorCode);
                    data[3].Size = sizeof(int);
                    message = message ?? String.Empty;
                    fixed (char* messageBytes = message)
                    {
                        data[4].DataPointer = (IntPtr)messageBytes;
                        data[4].Size = ((message.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(316, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipExitedUncleanly
        /// </summary>
        [Event(314, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Pip had unclean exit. Canceled: {2}, Error code {3}, Killed: {4}, # Surviving child errors: {5}")]
        public unsafe void PipExitedUncleanly(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, bool canceled, int errorCode, bool killed, int numSurvivingChildErrors)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                int canceledBytes = canceled ? 1 : 0;
                data[2].DataPointer = (IntPtr)(&canceledBytes);
                data[2].Size = 4;
                data[3].DataPointer = (IntPtr)(&errorCode);
                data[3].Size = sizeof(int);
                int killedBytes = killed ? 1 : 0;
                data[4].DataPointer = (IntPtr)(&killedBytes);
                data[4].Size = 4;
                data[5].DataPointer = (IntPtr)(&numSurvivingChildErrors);
                data[5].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(314, &relatedActivityId, 6, data);
            }
        }

        /// <summary>
        /// PipRetryDueToExitedWithAzureWatsonExitCode
        /// </summary>
        [Event(317, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Pip will be retried because its reported process '{2}' with pid '{3}' exited with Azure Watson's 0xDEAD exit code")]
        public unsafe void PipRetryDueToExitedWithAzureWatsonExitCode(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string process, uint processId)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                process = process ?? String.Empty;
                fixed (char* processBytes = process)
                {
                    data[2].DataPointer = (IntPtr)processBytes;
                    data[2].Size = ((process.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&processId);
                    data[3].Size = sizeof(uint);
                    WriteEventWithRelatedActivityIdCore(317, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode
        /// </summary>
        [Event(319, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Pip finished with some process (can be a child process) '{2} {3}' with pid '{4}' exited with Azure Watson's 0xDEAD exit code. Pip will not be cached if warning is treated as an error.")]
        public unsafe void PipFinishedWithSomeProcessExitedWithAzureWatsonExitCode(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string process, string args, uint processId)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                process = process ?? String.Empty;
                fixed (char* processBytes = process)
                {
                    data[2].DataPointer = (IntPtr)processBytes;
                    data[2].Size = ((process.Length + 1) * 2);
                    args = args ?? String.Empty;
                    fixed (char* argsBytes = args)
                    {
                        data[3].DataPointer = (IntPtr)argsBytes;
                        data[3].Size = ((args.Length + 1) * 2);
                        data[4].DataPointer = (IntPtr)(&processId);
                        data[4].Size = sizeof(uint);
                        WriteEventWithRelatedActivityIdCore(319, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessStandardInputException
        /// </summary>
        [Event(86, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}] Unexpected standard input exception: {4}")]
        public unsafe void PipProcessStandardInputException(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string exceptionMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        exceptionMessage = exceptionMessage ?? String.Empty;
                        fixed (char* exceptionMessageBytes = exceptionMessage)
                        {
                            data[4].DataPointer = (IntPtr)exceptionMessageBytes;
                            data[4].Size = ((exceptionMessage.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(86, &relatedActivityId, 5, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessToolErrorDueToHandleToFileBeingUsed
        /// </summary>
        [Event(14300, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}]The tool '{4}' cannot access the file '{5}' because it is being used by another process: \r\n{6}")]
        public unsafe void PipProcessToolErrorDueToHandleToFileBeingUsed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string toolName, string file, string reason)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[7];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        toolName = toolName ?? String.Empty;
                        fixed (char* toolNameBytes = toolName)
                        {
                            data[4].DataPointer = (IntPtr)toolNameBytes;
                            data[4].Size = ((toolName.Length + 1) * 2);
                            file = file ?? String.Empty;
                            fixed (char* fileBytes = file)
                            {
                                data[5].DataPointer = (IntPtr)fileBytes;
                                data[5].Size = ((file.Length + 1) * 2);
                                reason = reason ?? String.Empty;
                                fixed (char* reasonBytes = reason)
                                {
                                    data[6].DataPointer = (IntPtr)reasonBytes;
                                    data[6].Size = ((reason.Length + 1) * 2);
                                    WriteEventWithRelatedActivityIdCore(14300, &relatedActivityId, 7, data);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessError
        /// </summary>
        [Event(64, Level = EventLevel.Error, Keywords = (EventKeywords)129, Task = (EventTask)9, Message = "[{1}, {2}, {3}] - failed with exit code {8}{9}\r\n{5}\r\n{6}\r\n{7}")]
        public unsafe void PipProcessError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog, int exitCode, string optionalMessage, string shortPipDescription, long pipExecutionTimeMs)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[12];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        pipExe = pipExe ?? String.Empty;
                        fixed (char* pipExeBytes = pipExe)
                        {
                            data[4].DataPointer = (IntPtr)pipExeBytes;
                            data[4].Size = ((pipExe.Length + 1) * 2);
                            outputToLog = outputToLog ?? String.Empty;
                            fixed (char* outputToLogBytes = outputToLog)
                            {
                                data[5].DataPointer = (IntPtr)outputToLogBytes;
                                data[5].Size = ((outputToLog.Length + 1) * 2);
                                messageAboutPathsToLog = messageAboutPathsToLog ?? String.Empty;
                                fixed (char* messageAboutPathsToLogBytes = messageAboutPathsToLog)
                                {
                                    data[6].DataPointer = (IntPtr)messageAboutPathsToLogBytes;
                                    data[6].Size = ((messageAboutPathsToLog.Length + 1) * 2);
                                    pathsToLog = pathsToLog ?? String.Empty;
                                    fixed (char* pathsToLogBytes = pathsToLog)
                                    {
                                        data[7].DataPointer = (IntPtr)pathsToLogBytes;
                                        data[7].Size = ((pathsToLog.Length + 1) * 2);
                                        data[8].DataPointer = (IntPtr)(&exitCode);
                                        data[8].Size = sizeof(int);
                                        optionalMessage = optionalMessage ?? String.Empty;
                                        fixed (char* optionalMessageBytes = optionalMessage)
                                        {
                                            data[9].DataPointer = (IntPtr)optionalMessageBytes;
                                            data[9].Size = ((optionalMessage.Length + 1) * 2);
                                            shortPipDescription = shortPipDescription ?? String.Empty;
                                            fixed (char* shortPipDescriptionBytes = shortPipDescription)
                                            {
                                                data[10].DataPointer = (IntPtr)shortPipDescriptionBytes;
                                                data[10].Size = ((shortPipDescription.Length + 1) * 2);
                                                data[11].DataPointer = (IntPtr)(&pipExecutionTimeMs);
                                                data[11].Size = sizeof(long);
                                                WriteEventWithRelatedActivityIdCore(64, &relatedActivityId, 12, data);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessWarning
        /// </summary>
        [Event(65, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}] - warnings\r\n{5}\r\n{6}\r\n{7}")]
        public unsafe void PipProcessWarning(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string pipExe, string outputToLog, string messageAboutPathsToLog, string pathsToLog)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[8];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        pipExe = pipExe ?? String.Empty;
                        fixed (char* pipExeBytes = pipExe)
                        {
                            data[4].DataPointer = (IntPtr)pipExeBytes;
                            data[4].Size = ((pipExe.Length + 1) * 2);
                            outputToLog = outputToLog ?? String.Empty;
                            fixed (char* outputToLogBytes = outputToLog)
                            {
                                data[5].DataPointer = (IntPtr)outputToLogBytes;
                                data[5].Size = ((outputToLog.Length + 1) * 2);
                                messageAboutPathsToLog = messageAboutPathsToLog ?? String.Empty;
                                fixed (char* messageAboutPathsToLogBytes = messageAboutPathsToLog)
                                {
                                    data[6].DataPointer = (IntPtr)messageAboutPathsToLogBytes;
                                    data[6].Size = ((messageAboutPathsToLog.Length + 1) * 2);
                                    pathsToLog = pathsToLog ?? String.Empty;
                                    fixed (char* pathsToLogBytes = pathsToLog)
                                    {
                                        data[7].DataPointer = (IntPtr)pathsToLogBytes;
                                        data[7].Size = ((pathsToLog.Length + 1) * 2);
                                        WriteEventWithRelatedActivityIdCore(65, &relatedActivityId, 8, data);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessOutput
        /// </summary>
        [Event(66, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}]\r\n{4}")]
        public unsafe void PipProcessOutput(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string pipSpecPath, string pipWorkingDirectory, string outputToLog)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                pipSpecPath = pipSpecPath ?? String.Empty;
                fixed (char* pipSpecPathBytes = pipSpecPath)
                {
                    data[2].DataPointer = (IntPtr)pipSpecPathBytes;
                    data[2].Size = ((pipSpecPath.Length + 1) * 2);
                    pipWorkingDirectory = pipWorkingDirectory ?? String.Empty;
                    fixed (char* pipWorkingDirectoryBytes = pipWorkingDirectory)
                    {
                        data[3].DataPointer = (IntPtr)pipWorkingDirectoryBytes;
                        data[3].Size = ((pipWorkingDirectory.Length + 1) * 2);
                        outputToLog = outputToLog ?? String.Empty;
                        fixed (char* outputToLogBytes = outputToLog)
                        {
                            data[4].DataPointer = (IntPtr)outputToLogBytes;
                            data[4].Size = ((outputToLog.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(66, &relatedActivityId, 5, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipTempDirectoryCleanupFailure
        /// </summary>
        [Event(2201, Level = EventLevel.Warning, Keywords = (EventKeywords)65, Task = (EventTask)9, Message = "[{1}] Failed to clean temp directory at '{2}'. Pip may be retried or failed. {3}")]
        public unsafe void PipTempDirectoryCleanupFailure(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directory = directory ?? String.Empty;
                fixed (char* directoryBytes = directory)
                {
                    data[2].DataPointer = (IntPtr)directoryBytes;
                    data[2].Size = ((directory.Length + 1) * 2);
                    exceptionMessage = exceptionMessage ?? String.Empty;
                    fixed (char* exceptionMessageBytes = exceptionMessage)
                    {
                        data[3].DataPointer = (IntPtr)exceptionMessageBytes;
                        data[3].Size = ((exceptionMessage.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(2201, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipTempDirectorySetupFailure
        /// </summary>
        [Event(2203, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to create temp directory at '{2}'. Pip may be retried or failed. {3}")]
        public unsafe void PipTempDirectorySetupFailure(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directory, string exceptionMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directory = directory ?? String.Empty;
                fixed (char* directoryBytes = directory)
                {
                    data[2].DataPointer = (IntPtr)directoryBytes;
                    data[2].Size = ((directory.Length + 1) * 2);
                    exceptionMessage = exceptionMessage ?? String.Empty;
                    fixed (char* exceptionMessageBytes = exceptionMessage)
                    {
                        data[3].DataPointer = (IntPtr)exceptionMessageBytes;
                        data[3].Size = ((exceptionMessage.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(2203, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipTempSymlinkRedirectionError
        /// </summary>
        [Event(2205, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to create directory symlink '{2}' as a redirection for temp directory '{3}'. {4}")]
        public unsafe void PipTempSymlinkRedirectionError(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory, string exceptionMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directorySymlink = directorySymlink ?? String.Empty;
                fixed (char* directorySymlinkBytes = directorySymlink)
                {
                    data[2].DataPointer = (IntPtr)directorySymlinkBytes;
                    data[2].Size = ((directorySymlink.Length + 1) * 2);
                    tempDirectory = tempDirectory ?? String.Empty;
                    fixed (char* tempDirectoryBytes = tempDirectory)
                    {
                        data[3].DataPointer = (IntPtr)tempDirectoryBytes;
                        data[3].Size = ((tempDirectory.Length + 1) * 2);
                        exceptionMessage = exceptionMessage ?? String.Empty;
                        fixed (char* exceptionMessageBytes = exceptionMessage)
                        {
                            data[4].DataPointer = (IntPtr)exceptionMessageBytes;
                            data[4].Size = ((exceptionMessage.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(2205, &relatedActivityId, 5, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// PipTempSymlinkRedirection
        /// </summary>
        [Event(2206, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Create directory symlink '{2}' as a redirection for temp directory '{3}'")]
        public unsafe void PipTempSymlinkRedirection(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directorySymlink, string tempDirectory)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directorySymlink = directorySymlink ?? String.Empty;
                fixed (char* directorySymlinkBytes = directorySymlink)
                {
                    data[2].DataPointer = (IntPtr)directorySymlinkBytes;
                    data[2].Size = ((directorySymlink.Length + 1) * 2);
                    tempDirectory = tempDirectory ?? String.Empty;
                    fixed (char* tempDirectoryBytes = tempDirectory)
                    {
                        data[3].DataPointer = (IntPtr)tempDirectoryBytes;
                        data[3].Size = ((tempDirectory.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(2206, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipFailedToCreateDumpFile
        /// </summary>
        [Event(2210, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to create dump for timed out process. {2}")]
        public unsafe void PipFailedToCreateDumpFile(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string exceptionMessage)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                exceptionMessage = exceptionMessage ?? String.Empty;
                fixed (char* exceptionMessageBytes = exceptionMessage)
                {
                    data[2].DataPointer = (IntPtr)exceptionMessageBytes;
                    data[2].Size = ((exceptionMessage.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(2210, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// RetryStartPipDueToErrorPartialCopyDuringDetours
        /// </summary>
        [Event(85, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}]Retry to start pip for {3} time(s) due to the following error: {2}")]
        public unsafe void RetryStartPipDueToErrorPartialCopyDuringDetours(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int error, int retryNumber)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&error);
                data[2].Size = sizeof(int);
                data[3].DataPointer = (IntPtr)(&retryNumber);
                data[3].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(85, &relatedActivityId, 4, data);
            }
        }

        /// <summary>
        /// DuplicateWindowsEnvironmentVariableEncountered
        /// </summary>
        [Event(336, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "Unexpected duplicate environment variable encountered. Variable '{0}' has already been defined with value '{1}'. The other occurrence with value '{2}' will be ignored.")]
        public unsafe void DuplicateWindowsEnvironmentVariableEncountered(Guid relatedActivityId, string key, string existingValue, string ignoredValue)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            key = key ?? String.Empty;
            fixed (char* keyBytes = key)
            {
                data[0].DataPointer = (IntPtr)keyBytes;
                data[0].Size = ((key.Length + 1) * 2);
                existingValue = existingValue ?? String.Empty;
                fixed (char* existingValueBytes = existingValue)
                {
                    data[1].DataPointer = (IntPtr)existingValueBytes;
                    data[1].Size = ((existingValue.Length + 1) * 2);
                    ignoredValue = ignoredValue ?? String.Empty;
                    fixed (char* ignoredValueBytes = ignoredValue)
                    {
                        data[2].DataPointer = (IntPtr)ignoredValueBytes;
                        data[2].Size = ((ignoredValue.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(336, &relatedActivityId, 3, data);
                    }
                }
            }
        }

        /// <summary>
        /// ReadWriteFileAccessConvertedToReadMessage
        /// </summary>
        [Event(19, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] File access on file '{3}' requested with Read/Write but granted for Read only by process with ID: {2}.")]
        public unsafe void ReadWriteFileAccessConvertedToReadMessage(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, uint processId, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&processId);
                data[2].Size = sizeof(uint);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[3].DataPointer = (IntPtr)pathBytes;
                    data[3].Size = ((path.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(19, &relatedActivityId, 4, data);
                }
            }
        }

        /// <summary>
        /// ReadWriteFileAccessConvertedToReadWarning
        /// </summary>
        [Event(21, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] This pip might have failed because of converting Read/Write file access to a Read file access. Examine the execution log for information on which files the Read/Write access request was converted to Read access request.")]
        public unsafe void ReadWriteFileAccessConvertedToReadWarning(Guid relatedActivityId, long pipSemiStableHash, string pipDescription)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(21, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// PipProcessResponseFileCreationFailed
        /// </summary>
        [Event(74, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}, {2}, {3}]Process response file could not be prepared, path '{2}', error code {3:X8}: {4}")]
        public unsafe void PipProcessResponseFileCreationFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&errorCode);
                    data[3].Size = sizeof(int);
                    message = message ?? String.Empty;
                    fixed (char* messageBytes = message)
                    {
                        data[4].DataPointer = (IntPtr)messageBytes;
                        data[4].Size = ((message.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(74, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate
        /// </summary>
        [Event(53, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failed to preserve output directory '{2}' because '{3}' cannot be made private, contents of the directory will be deleted")]
        public unsafe void PipProcessPreserveOutputDirectoryFailedToMakeFilePrivate(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directory, string file)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directory = directory ?? String.Empty;
                fixed (char* directoryBytes = directory)
                {
                    data[2].DataPointer = (IntPtr)directoryBytes;
                    data[2].Size = ((directory.Length + 1) * 2);
                    file = file ?? String.Empty;
                    fixed (char* fileBytes = file)
                    {
                        data[3].DataPointer = (IntPtr)fileBytes;
                        data[3].Size = ((file.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(53, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessPreserveOutputDirectorySkipMakeFilesPrivate
        /// </summary>
        [Event(54, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Output directory '{2}' is not preserved because /unsafe_IgnorePreserveOutputsPrivatization. This can cause failure in pip execution.")]
        public unsafe void PipProcessPreserveOutputDirectorySkipMakeFilesPrivate(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string directory)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                directory = directory ?? String.Empty;
                fixed (char* directoryBytes = directory)
                {
                    data[2].DataPointer = (IntPtr)directoryBytes;
                    data[2].Size = ((directory.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(54, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessChangeAffectedInputsWrittenFileCreationFailed
        /// </summary>
        [Event(90, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] File containing change affected inputs could not be prepared, path '{2}', error code {3:X8}: {4}")]
        public unsafe void PipProcessChangeAffectedInputsWrittenFileCreationFailed(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string path, int errorCode, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[2].DataPointer = (IntPtr)pathBytes;
                    data[2].Size = ((path.Length + 1) * 2);
                    data[3].DataPointer = (IntPtr)(&errorCode);
                    data[3].Size = sizeof(int);
                    message = message ?? String.Empty;
                    fixed (char* messageBytes = message)
                    {
                        data[4].DataPointer = (IntPtr)messageBytes;
                        data[4].Size = ((message.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(90, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// FailedToCreateHardlinkOnMerge
        /// </summary>
        [Event(12209, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)3, Message = "[{1}] Cannot create a hardlink from '{3}' to '{2}' when merging outputs to their original location: {4}")]
        public unsafe void FailedToCreateHardlinkOnMerge(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile, string failedStatus)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                destinationFile = destinationFile ?? String.Empty;
                fixed (char* destinationFileBytes = destinationFile)
                {
                    data[2].DataPointer = (IntPtr)destinationFileBytes;
                    data[2].Size = ((destinationFile.Length + 1) * 2);
                    sourceFile = sourceFile ?? String.Empty;
                    fixed (char* sourceFileBytes = sourceFile)
                    {
                        data[3].DataPointer = (IntPtr)sourceFileBytes;
                        data[3].Size = ((sourceFile.Length + 1) * 2);
                        failedStatus = failedStatus ?? String.Empty;
                        fixed (char* failedStatusBytes = failedStatus)
                        {
                            data[4].DataPointer = (IntPtr)failedStatusBytes;
                            data[4].Size = ((failedStatus.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(12209, &relatedActivityId, 5, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// DisallowedDoubleWriteOnMerge
        /// </summary>
        [Event(12211, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)3, Message = "[{1}] A disallowed double write was detected when merging '{3}' to '{2}'.")]
        public unsafe void DisallowedDoubleWriteOnMerge(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string destinationFile, string sourceFile)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                destinationFile = destinationFile ?? String.Empty;
                fixed (char* destinationFileBytes = destinationFile)
                {
                    data[2].DataPointer = (IntPtr)destinationFileBytes;
                    data[2].Size = ((destinationFile.Length + 1) * 2);
                    sourceFile = sourceFile ?? String.Empty;
                    fixed (char* sourceFileBytes = sourceFile)
                    {
                        data[3].DataPointer = (IntPtr)sourceFileBytes;
                        data[3].Size = ((sourceFile.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(12211, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// DoubleWriteAllowedDueToPolicy
        /// </summary>
        [Event(12210, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)3, Message = "[{1}] Detected double write in '{2}' when merging outputs to their original location. The double write is allowed due to configured policy.")]
        public unsafe void DoubleWriteAllowedDueToPolicy(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string destinationFile)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                destinationFile = destinationFile ?? String.Empty;
                fixed (char* destinationFileBytes = destinationFile)
                {
                    data[2].DataPointer = (IntPtr)destinationFileBytes;
                    data[2].Size = ((destinationFile.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(12210, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessStartExternalTool
        /// </summary>
        [Event(78, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process execution via external tool '{2}' starts")]
        public unsafe void PipProcessStartExternalTool(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string tool)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                tool = tool ?? String.Empty;
                fixed (char* toolBytes = tool)
                {
                    data[2].DataPointer = (IntPtr)toolBytes;
                    data[2].Size = ((tool.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(78, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFinishedExternalTool
        /// </summary>
        [Event(79, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process execution via external tool finished with the tool's exit code {2}:{3}{4}")]
        public unsafe void PipProcessFinishedExternalTool(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&exitCode);
                data[2].Size = sizeof(int);
                stdOut = stdOut ?? String.Empty;
                fixed (char* stdOutBytes = stdOut)
                {
                    data[3].DataPointer = (IntPtr)stdOutBytes;
                    data[3].Size = ((stdOut.Length + 1) * 2);
                    stdErr = stdErr ?? String.Empty;
                    fixed (char* stdErrBytes = stdErr)
                    {
                        data[4].DataPointer = (IntPtr)stdErrBytes;
                        data[4].Size = ((stdErr.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(79, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessStartRemoteExecution
        /// </summary>
        [Event(12502, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Remoting process execution via '{2}' starts")]
        public unsafe void PipProcessStartRemoteExecution(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string tool)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                tool = tool ?? String.Empty;
                fixed (char* toolBytes = tool)
                {
                    data[2].DataPointer = (IntPtr)toolBytes;
                    data[2].Size = ((tool.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(12502, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessFinishedRemoteExecution
        /// </summary>
        [Event(12503, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Remoting process execution via external tool finished with the tool's exit code {2}:{3}{4}")]
        public unsafe void PipProcessFinishedRemoteExecution(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&exitCode);
                data[2].Size = sizeof(int);
                stdOut = stdOut ?? String.Empty;
                fixed (char* stdOutBytes = stdOut)
                {
                    data[3].DataPointer = (IntPtr)stdOutBytes;
                    data[3].Size = ((stdOut.Length + 1) * 2);
                    stdErr = stdErr ?? String.Empty;
                    fixed (char* stdErrBytes = stdErr)
                    {
                        data[4].DataPointer = (IntPtr)stdErrBytes;
                        data[4].Size = ((stdErr.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(12503, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessStartExternalVm
        /// </summary>
        [Event(80, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process execution in VM starts")]
        public unsafe void PipProcessStartExternalVm(Guid relatedActivityId, long pipSemiStableHash, string pipDescription)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(80, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// PipProcessFinishedExternalVm
        /// </summary>
        [Event(81, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process execution in VM finished with VM's command proxy exit code {2}:{3}{4}")]
        public unsafe void PipProcessFinishedExternalVm(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, int exitCode, string stdOut, string stdErr)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[5];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                data[2].DataPointer = (IntPtr)(&exitCode);
                data[2].Size = sizeof(int);
                stdOut = stdOut ?? String.Empty;
                fixed (char* stdOutBytes = stdOut)
                {
                    data[3].DataPointer = (IntPtr)stdOutBytes;
                    data[3].Size = ((stdOut.Length + 1) * 2);
                    stdErr = stdErr ?? String.Empty;
                    fixed (char* stdErrBytes = stdErr)
                    {
                        data[4].DataPointer = (IntPtr)stdErrBytes;
                        data[4].Size = ((stdErr.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(81, &relatedActivityId, 5, data);
                    }
                }
            }
        }

        /// <summary>
        /// PipProcessExternalExecution
        /// </summary>
        [Event(82, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] External execution: {2}")]
        public unsafe void PipProcessExternalExecution(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, string message)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                message = message ?? String.Empty;
                fixed (char* messageBytes = message)
                {
                    data[2].DataPointer = (IntPtr)messageBytes;
                    data[2].Size = ((message.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(82, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PipProcessNeedsExecuteExternalButExecuteInternal
        /// </summary>
        [Event(92, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Process needs to be executed externally because (require admin privilege: {2} | execution mode: {3}), but instead it executes internally because (Win OS: {4} | listener existence: {5})")]
        public unsafe void PipProcessNeedsExecuteExternalButExecuteInternal(Guid relatedActivityId, long pipSemiStableHash, string pipDescription, bool requiredAdminPrivilege, string executionMode, bool isWinOS, bool existsListener)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[6];
            data[0].DataPointer = (IntPtr)(&pipSemiStableHash);
            data[0].Size = sizeof(long);
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[1].DataPointer = (IntPtr)pipDescriptionBytes;
                data[1].Size = ((pipDescription.Length + 1) * 2);
                int requiredAdminPrivilegeBytes = requiredAdminPrivilege ? 1 : 0;
                data[2].DataPointer = (IntPtr)(&requiredAdminPrivilegeBytes);
                data[2].Size = 4;
                executionMode = executionMode ?? String.Empty;
                fixed (char* executionModeBytes = executionMode)
                {
                    data[3].DataPointer = (IntPtr)executionModeBytes;
                    data[3].Size = ((executionMode.Length + 1) * 2);
                    int isWinOSBytes = isWinOS ? 1 : 0;
                    data[4].DataPointer = (IntPtr)(&isWinOSBytes);
                    data[4].Size = 4;
                    int existsListenerBytes = existsListener ? 1 : 0;
                    data[5].DataPointer = (IntPtr)(&existsListenerBytes);
                    data[5].Size = 4;
                    WriteEventWithRelatedActivityIdCore(92, &relatedActivityId, 6, data);
                }
            }
        }

        /// <summary>
        /// LogPhaseDuration
        /// </summary>
        [Event(93, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435456, Task = (EventTask)9, Message = "[{0}] Done with phase '{1}' in {2}.  {3}")]
        public unsafe void LogPhaseDuration(Guid relatedActivityId, string pipSemiStableHash, string phaseName, string duration, string extraInfo)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            pipSemiStableHash = pipSemiStableHash ?? String.Empty;
            fixed (char* pipSemiStableHashBytes = pipSemiStableHash)
            {
                data[0].DataPointer = (IntPtr)pipSemiStableHashBytes;
                data[0].Size = ((pipSemiStableHash.Length + 1) * 2);
                phaseName = phaseName ?? String.Empty;
                fixed (char* phaseNameBytes = phaseName)
                {
                    data[1].DataPointer = (IntPtr)phaseNameBytes;
                    data[1].Size = ((phaseName.Length + 1) * 2);
                    duration = duration ?? String.Empty;
                    fixed (char* durationBytes = duration)
                    {
                        data[2].DataPointer = (IntPtr)durationBytes;
                        data[2].Size = ((duration.Length + 1) * 2);
                        extraInfo = extraInfo ?? String.Empty;
                        fixed (char* extraInfoBytes = extraInfo)
                        {
                            data[3].DataPointer = (IntPtr)extraInfoBytes;
                            data[3].Size = ((extraInfo.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(93, &relatedActivityId, 4, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// CannotDeleteSharedOpaqueOutputFile
        /// </summary>
        [Event(877, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "[{0}] Failed to delete shared opaque output files recorded in '{1}':{2}.  Reason: {3}")]
        public unsafe void CannotDeleteSharedOpaqueOutputFile(Guid relatedActivityId, string pipDescription, string sidebandFile, string files, string failure)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                sidebandFile = sidebandFile ?? String.Empty;
                fixed (char* sidebandFileBytes = sidebandFile)
                {
                    data[1].DataPointer = (IntPtr)sidebandFileBytes;
                    data[1].Size = ((sidebandFile.Length + 1) * 2);
                    files = files ?? String.Empty;
                    fixed (char* filesBytes = files)
                    {
                        data[2].DataPointer = (IntPtr)filesBytes;
                        data[2].Size = ((files.Length + 1) * 2);
                        failure = failure ?? String.Empty;
                        fixed (char* failureBytes = failure)
                        {
                            data[3].DataPointer = (IntPtr)failureBytes;
                            data[3].Size = ((failure.Length + 1) * 2);
                            WriteEventWithRelatedActivityIdCore(877, &relatedActivityId, 4, data);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// SharedOpaqueOutputsDeletedLazily
        /// </summary>
        [Event(874, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "[{0}] Lazily deleted {3} shared opaque output files recorded in '{1}':{2}.")]
        public unsafe void SharedOpaqueOutputsDeletedLazily(Guid relatedActivityId, string pipDescription, string sidebandFile, string files, int count)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[4];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                sidebandFile = sidebandFile ?? String.Empty;
                fixed (char* sidebandFileBytes = sidebandFile)
                {
                    data[1].DataPointer = (IntPtr)sidebandFileBytes;
                    data[1].Size = ((sidebandFile.Length + 1) * 2);
                    files = files ?? String.Empty;
                    fixed (char* filesBytes = files)
                    {
                        data[2].DataPointer = (IntPtr)filesBytes;
                        data[2].Size = ((files.Length + 1) * 2);
                        data[3].DataPointer = (IntPtr)(&count);
                        data[3].Size = sizeof(int);
                        WriteEventWithRelatedActivityIdCore(874, &relatedActivityId, 4, data);
                    }
                }
            }
        }

        /// <summary>
        /// CannotReadSidebandFileError
        /// </summary>
        [Event(875, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "Cannot read sideband file '{0}': {1}")]
        public unsafe void CannotReadSidebandFileError(Guid relatedActivityId, string fileName, string error)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            fileName = fileName ?? String.Empty;
            fixed (char* fileNameBytes = fileName)
            {
                data[0].DataPointer = (IntPtr)fileNameBytes;
                data[0].Size = ((fileName.Length + 1) * 2);
                error = error ?? String.Empty;
                fixed (char* errorBytes = error)
                {
                    data[1].DataPointer = (IntPtr)errorBytes;
                    data[1].Size = ((error.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(875, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// CannotReadSidebandFileWarning
        /// </summary>
        [Event(876, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "Cannot read sideband file '{0}': {1}")]
        public unsafe void CannotReadSidebandFileWarning(Guid relatedActivityId, string fileName, string error)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            fileName = fileName ?? String.Empty;
            fixed (char* fileNameBytes = fileName)
            {
                data[0].DataPointer = (IntPtr)fileNameBytes;
                data[0].Size = ((fileName.Length + 1) * 2);
                error = error ?? String.Empty;
                fixed (char* errorBytes = error)
                {
                    data[1].DataPointer = (IntPtr)errorBytes;
                    data[1].Size = ((error.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(876, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ResumeOrSuspendProcessError
        /// </summary>
        [Event(878, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "[{0}] occurred an error for {1}: {2}")]
        public unsafe void ResumeOrSuspendProcessError(Guid relatedActivityId, string pipSemiStableHash, string failedOperation, int errorCode)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            pipSemiStableHash = pipSemiStableHash ?? String.Empty;
            fixed (char* pipSemiStableHashBytes = pipSemiStableHash)
            {
                data[0].DataPointer = (IntPtr)pipSemiStableHashBytes;
                data[0].Size = ((pipSemiStableHash.Length + 1) * 2);
                failedOperation = failedOperation ?? String.Empty;
                fixed (char* failedOperationBytes = failedOperation)
                {
                    data[1].DataPointer = (IntPtr)failedOperationBytes;
                    data[1].Size = ((failedOperation.Length + 1) * 2);
                    data[2].DataPointer = (IntPtr)(&errorCode);
                    data[2].Size = sizeof(int);
                    WriteEventWithRelatedActivityIdCore(878, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// ResumeOrSuspendException
        /// </summary>
        [Event(879, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435457, Task = (EventTask)5, Message = "{0} attempt failed with exception. {1}")]
        public unsafe void ResumeOrSuspendException(Guid relatedActivityId, string operation, string exception)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            operation = operation ?? String.Empty;
            fixed (char* operationBytes = operation)
            {
                data[0].DataPointer = (IntPtr)operationBytes;
                data[0].Size = ((operation.Length + 1) * 2);
                exception = exception ?? String.Empty;
                fixed (char* exceptionBytes = exception)
                {
                    data[1].DataPointer = (IntPtr)exceptionBytes;
                    data[1].Size = ((exception.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(879, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// CannotProbeOutputUnderSharedOpaque
        /// </summary>
        [Event(275, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)6, Message = "[{0}] Failed to probe '{1}' under a shared opaque directory : {2}")]
        public unsafe void CannotProbeOutputUnderSharedOpaque(Guid relatedActivityId, string pipDescription, string path, string details)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                path = path ?? String.Empty;
                fixed (char* pathBytes = path)
                {
                    data[1].DataPointer = (IntPtr)pathBytes;
                    data[1].Size = ((path.Length + 1) * 2);
                    details = details ?? String.Empty;
                    fixed (char* detailsBytes = details)
                    {
                        data[2].DataPointer = (IntPtr)detailsBytes;
                        data[2].Size = ((details.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(275, &relatedActivityId, 3, data);
                    }
                }
            }
        }

        /// <summary>
        /// DumpSurvivingPipProcessChildrenStatus
        /// </summary>
        [Event(12213, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{1}] Failure during dumping unexpected surviving child processes for Process: '{0}'. Status: {1}")]
        public unsafe void DumpSurvivingPipProcessChildrenStatus(Guid relatedActivityId, string processName, string status)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            processName = processName ?? String.Empty;
            fixed (char* processNameBytes = processName)
            {
                data[0].DataPointer = (IntPtr)processNameBytes;
                data[0].Size = ((processName.Length + 1) * 2);
                status = status ?? String.Empty;
                fixed (char* statusBytes = status)
                {
                    data[1].DataPointer = (IntPtr)statusBytes;
                    data[1].Size = ((status.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(12213, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ExistenceAssertionUnderOutputDirectoryFailed
        /// </summary>
        [Event(12214, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{0}] The output file '{1}' existence was asserted under output directory root '{2}' but the file was not produced by the pip.")]
        public unsafe void ExistenceAssertionUnderOutputDirectoryFailed(Guid relatedActivityId, string pipDescription, string assertedOutput, string outputDirectoryRoot)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                assertedOutput = assertedOutput ?? String.Empty;
                fixed (char* assertedOutputBytes = assertedOutput)
                {
                    data[1].DataPointer = (IntPtr)assertedOutputBytes;
                    data[1].Size = ((assertedOutput.Length + 1) * 2);
                    outputDirectoryRoot = outputDirectoryRoot ?? String.Empty;
                    fixed (char* outputDirectoryRootBytes = outputDirectoryRoot)
                    {
                        data[2].DataPointer = (IntPtr)outputDirectoryRootBytes;
                        data[2].Size = ((outputDirectoryRoot.Length + 1) * 2);
                        WriteEventWithRelatedActivityIdCore(12214, &relatedActivityId, 3, data);
                    }
                }
            }
        }

        /// <summary>
        /// SandboxedProcessResultLogOutputTimeout
        /// </summary>
        [Event(12514, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{0}] Logging process StandardOutput/StandardError timed out after exceeding '{1}' minutes. This may be caused by the default terminal being Windows Terminal, workaround this by switching the default terminal to 'Windows Console Host' in Windows settings or Windows Terminal settings. Output streams may be incomplete due to this error.")]
        public unsafe void SandboxedProcessResultLogOutputTimeout(Guid relatedActivityId, string pipSemiStableHash, int timeoutInMinutes)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipSemiStableHash = pipSemiStableHash ?? String.Empty;
            fixed (char* pipSemiStableHashBytes = pipSemiStableHash)
            {
                data[0].DataPointer = (IntPtr)pipSemiStableHashBytes;
                data[0].Size = ((pipSemiStableHash.Length + 1) * 2);
                data[1].DataPointer = (IntPtr)(&timeoutInMinutes);
                data[1].Size = sizeof(int);
                WriteEventWithRelatedActivityIdCore(12514, &relatedActivityId, 2, data);
            }
        }

        /// <summary>
        /// LinuxSandboxReportedBinaryRequiringPTrace
        /// </summary>
        [Event(10104, Level = EventLevel.Warning, Keywords = (EventKeywords)1, Task = (EventTask)9, Message = "[{0}] The following processes '{1}' require ptrace and their file accesses may not be reported by the sandbox.")]
        public unsafe void LinuxSandboxReportedBinaryRequiringPTrace(Guid relatedActivityId, string pipDescription, string exePath)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                exePath = exePath ?? String.Empty;
                fixed (char* exePathBytes = exePath)
                {
                    data[1].DataPointer = (IntPtr)exePathBytes;
                    data[1].Size = ((exePath.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10104, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// PTraceSandboxLaunchedForPip
        /// </summary>
        [Event(10106, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435457, Task = (EventTask)9, Message = "[{0}] Ptrace sandbox was launched for the following processes '{1}'.")]
        public unsafe void PTraceSandboxLaunchedForPip(Guid relatedActivityId, string pipDescription, string exePath)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                exePath = exePath ?? String.Empty;
                fixed (char* exePathBytes = exePath)
                {
                    data[1].DataPointer = (IntPtr)exePathBytes;
                    data[1].Size = ((exePath.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10106, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ProcessBreakaway
        /// </summary>
        [Event(14303, Level = EventLevel.Verbose, Keywords = (EventKeywords)268435457, Task = (EventTask)9, Message = "[{0}] Process {2} with path '{1}' breaks away from the sandbox.")]
        public unsafe void ProcessBreakaway(Guid relatedActivityId, string pipDescription, string exePath, uint pid)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[3];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                exePath = exePath ?? String.Empty;
                fixed (char* exePathBytes = exePath)
                {
                    data[1].DataPointer = (IntPtr)exePathBytes;
                    data[1].Size = ((exePath.Length + 1) * 2);
                    data[2].DataPointer = (IntPtr)(&pid);
                    data[2].Size = sizeof(uint);
                    WriteEventWithRelatedActivityIdCore(14303, &relatedActivityId, 3, data);
                }
            }
        }

        /// <summary>
        /// PTraceRunnerError
        /// </summary>
        [Event(10105, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)1, Message = "[{0}] PTraceRunner logged the following error: {1}")]
        public unsafe void PTraceRunnerError(Guid relatedActivityId, string pipDescription, string content)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                content = content ?? String.Empty;
                fixed (char* contentBytes = content)
                {
                    data[1].DataPointer = (IntPtr)contentBytes;
                    data[1].Size = ((content.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10105, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ReportArgsMismatch
        /// </summary>
        [Event(10107, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)1, Message = "[{0}] Received ProcessCommandLine report without a matching ProcessStart report for pid '{1}'.")]
        public unsafe void ReportArgsMismatch(Guid relatedActivityId, string pipDescription, string pid)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                pid = pid ?? String.Empty;
                fixed (char* pidBytes = pid)
                {
                    data[1].DataPointer = (IntPtr)pidBytes;
                    data[1].Size = ((pid.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10107, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ReceivedReportFromUnknownPid
        /// </summary>
        [Event(10108, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)1, Message = "[{0}] Received report from unknown pid: {1}")]
        public unsafe void ReceivedReportFromUnknownPid(Guid relatedActivityId, string pipDescription, string pid)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[2];
            pipDescription = pipDescription ?? String.Empty;
            fixed (char* pipDescriptionBytes = pipDescription)
            {
                data[0].DataPointer = (IntPtr)pipDescriptionBytes;
                data[0].Size = ((pipDescription.Length + 1) * 2);
                pid = pid ?? String.Empty;
                fixed (char* pidBytes = pid)
                {
                    data[1].DataPointer = (IntPtr)pidBytes;
                    data[1].Size = ((pid.Length + 1) * 2);
                    WriteEventWithRelatedActivityIdCore(10108, &relatedActivityId, 2, data);
                }
            }
        }

        /// <summary>
        /// ReceivedFileAccessReportBeforeSemaphoreInit
        /// </summary>
        [Event(10109, Level = EventLevel.Verbose, Keywords = (EventKeywords)1, Task = (EventTask)1, Message = "The following file access occurred before the BxlObserver was able to complete initialization '{0}'")]
        public unsafe void ReceivedFileAccessReportBeforeSemaphoreInit(Guid relatedActivityId, string path)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            path = path ?? String.Empty;
            fixed (char* pathBytes = path)
            {
                data[0].DataPointer = (IntPtr)pathBytes;
                data[0].Size = ((path.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(10109, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// EnvironmentPreparationFailed
        /// </summary>
        [Event(14302, Level = EventLevel.Error, Keywords = (EventKeywords)1, Task = (EventTask)23, Message = "Could not prepare environment variables. Error: {0}")]
        public unsafe void EnvironmentPreparationFailed(Guid relatedActivityId, string error)
        {
            EventSource.EventData* data = stackalloc EventSource.EventData[1];
            error = error ?? String.Empty;
            fixed (char* errorBytes = error)
            {
                data[0].DataPointer = (IntPtr)errorBytes;
                data[0].Size = ((error.Length + 1) * 2);
                WriteEventWithRelatedActivityIdCore(14302, &relatedActivityId, 1, data);
            }
        }

        /// <summary>
        /// Event Keywords
        /// </summary>
        public static class Keywords
        {
            /// <summary>
            /// Diagnostics
            /// </summary>
            public const EventKeywords Diagnostics = (EventKeywords)(268435456);
            /// <summary>
            /// UserMessage
            /// </summary>
            public const EventKeywords UserMessage = (EventKeywords)(1);
            /// <summary>
            /// Progress
            /// </summary>
            public const EventKeywords Progress = (EventKeywords)(2);
            /// <summary>
            /// Overwritable
            /// </summary>
            public const EventKeywords Overwritable = (EventKeywords)(8);
            /// <summary>
            /// OverwritableOnly
            /// </summary>
            public const EventKeywords OverwritableOnly = (EventKeywords)(16);
            /// <summary>
            /// ExternalEtwOnly
            /// </summary>
            public const EventKeywords ExternalEtwOnly = (EventKeywords)(32);
            /// <summary>
            /// InfrastructureIssue
            /// </summary>
            public const EventKeywords InfrastructureIssue = (EventKeywords)(64);
            /// <summary>
            /// UserError
            /// </summary>
            public const EventKeywords UserError = (EventKeywords)(128);
            /// <summary>
            /// NotForwardedToOrchestrator
            /// </summary>
            public const EventKeywords NotForwardedToOrchestrator = (EventKeywords)(256);
            /// <summary>
            /// SelectivelyEnabled
            /// </summary>
            public const EventKeywords SelectivelyEnabled = (EventKeywords)(512);
        }

        /// <summary>
        /// Event Tasks
        /// </summary>
        public static class Tasks
        {
            /// <summary>
            /// Scheduler
            /// </summary>
            public const EventTask Scheduler = (EventTask)(1);
            /// <summary>
            /// Parser
            /// </summary>
            public const EventTask Parser = (EventTask)(2);
            /// <summary>
            /// Storage
            /// </summary>
            public const EventTask Storage = (EventTask)(3);
            /// <summary>
            /// UnitTest
            /// </summary>
            public const EventTask UnitTest = (EventTask)(4);
            /// <summary>
            /// SandboxedProcessExecutor
            /// </summary>
            public const EventTask SandboxedProcessExecutor = (EventTask)(5);
            /// <summary>
            /// Engine
            /// </summary>
            public const EventTask Engine = (EventTask)(6);
            /// <summary>
            /// Viewer
            /// </summary>
            public const EventTask Viewer = (EventTask)(7);
            /// <summary>
            /// UnitTest2
            /// </summary>
            public const EventTask UnitTest2 = (EventTask)(8);
            /// <summary>
            /// PipExecutor
            /// </summary>
            public const EventTask PipExecutor = (EventTask)(9);
            /// <summary>
            /// ChangeJournalService
            /// </summary>
            public const EventTask ChangeJournalService = (EventTask)(10);
            /// <summary>
            /// HostApplication
            /// </summary>
            public const EventTask HostApplication = (EventTask)(11);
            /// <summary>
            /// CommonInfrastructure
            /// </summary>
            public const EventTask CommonInfrastructure = (EventTask)(12);
            /// <summary>
            /// CacheInteraction
            /// </summary>
            public const EventTask CacheInteraction = (EventTask)(13);
            /// <summary>
            /// Debugger
            /// </summary>
            public const EventTask Debugger = (EventTask)(14);
            /// <summary>
            /// Analyzers
            /// </summary>
            public const EventTask Analyzers = (EventTask)(15);
            /// <summary>
            /// PipInputAssertions
            /// </summary>
            public const EventTask PipInputAssertions = (EventTask)(16);
            /// <summary>
            /// Distribution
            /// </summary>
            public const EventTask Distribution = (EventTask)(17);
            /// <summary>
            /// CriticalPaths
            /// </summary>
            public const EventTask CriticalPaths = (EventTask)(18);
            /// <summary>
            /// ChangeDetection
            /// </summary>
            public const EventTask ChangeDetection = (EventTask)(19);
            /// <summary>
            /// Unclassified
            /// </summary>
            public const EventTask Unclassified = (EventTask)(20);
            /// <summary>
            /// LanguageServer
            /// </summary>
            public const EventTask LanguageServer = (EventTask)(21);
            /// <summary>
            /// ExecutionAnalyzers
            /// </summary>
            public const EventTask ExecutionAnalyzers = (EventTask)(22);
            /// <summary>
            /// Plugin
            /// </summary>
            public const EventTask Plugin = (EventTask)(23);
            /// <summary>
            /// Max
            /// </summary>
            public const EventTask Max = (EventTask)(23);
        }
    }
}